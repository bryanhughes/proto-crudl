<?xml version="1.0" encoding="UTF-8" ?>
<project name="test_schema" id="Project_35d47c4" database="PostgreSQL" >
	<schema name="public" >
		<table name="example_a" >
			<comment><![CDATA[If generated by DBSchema, then SQL file needs to be fixed up. The '[]' needs to be part of the datatype (no spaces)]]></comment>
			<column name="column_a" type="varchar" jt="12" mandatory="y" />
			<column name="column_b" type="varchar" jt="12" mandatory="y" />
			<column name="column_c" type="integer" jt="4" />
			<column name="column_d" type="integer[]" jt="2003" />
			<column name="column_e" type="varchar[]" jt="2003" />
			<column name="column_f" type="text[]" jt="2003" />
			<column name="column_g" type="bool[]" jt="2003" />
			<column name="column_h" type="json[]" jt="2003" />
			<column name="column_i" type="varchar" jt="12" mandatory="y" />
			<index name="pk_example_a" unique="PRIMARY_KEY" >
				<column name="column_a" />
				<column name="column_b" />
			</index>
			<index name="idx_example_a" unique="NORMAL" >
				<column name="column_c" />
			</index>
			<index name="unq_example_a" unique="UNIQUE_KEY" >
				<column name="column_i" />
			</index>
		</table>
		<table name="example_b" >
			<column name="column_a" type="varchar" jt="12" mandatory="y" />
			<column name="column_b1" type="varchar" jt="12" mandatory="y" />
			<column name="column_1" type="integer" jt="4" mandatory="y" />
			<column name="test_id" type="integer" jt="4" />
			<column name="p_bar" type="varchar" jt="12" />
			<column name="t_bar" type="varchar" jt="12" />
			<index name="pk_example_b_column_1" unique="PRIMARY_KEY" >
				<column name="column_1" />
			</index>
			<index name="list_by_public_foo" unique="NORMAL" >
				<column name="p_bar" />
			</index>
			<index name="unq_example_b_column_a" unique="UNIQUE_KEY" >
				<column name="column_a" />
			</index>
			<fk name="fk_example_b_example_a" to_schema="public" to_table="example_a" >
				<fk_column name="column_a" pk="column_a" />
				<fk_column name="column_b1" pk="column_b" />
			</fk>
			<fk name="fk_example_b_test_table_pkey" to_schema="test_schema" to_table="test_table_pkey" >
				<fk_column name="test_id" pk="id" />
			</fk>
			<fk name="fk_example_b_pfoo" to_schema="public" to_table="foo" >
				<fk_column name="p_bar" pk="bar" />
			</fk>
			<fk name="fk_example_b_tfoo" to_schema="test_schema" to_table="foo" >
				<fk_column name="t_bar" pk="bar" />
			</fk>
		</table>
		<table name="example_c" >
			<column name="column_aa" type="integer" jt="4" mandatory="y" >
				<identity><![CDATA[GENERATED BY DEFAULT AS IDENTITY]]></identity>
			</column>
			<column name="column_a" type="varchar" jt="12" mandatory="y" >
				<comment><![CDATA[This shows a weird corner case where a column that is part of a composite foreign key is referencing another table as a single column]]></comment>
			</column>
			<index name="pk_example_c_column_aa" unique="PRIMARY_KEY" >
				<column name="column_aa" />
			</index>
			<fk name="fk_example_c_example_b" to_schema="public" to_table="example_b" >
				<fk_column name="column_a" pk="column_a" />
			</fk>
		</table>
		<table name="excluded" >
			<column name="column1" type="integer" jt="4" mandatory="y" />
			<column name="column2" type="integer" jt="4" mandatory="y" />
			<column name="column3" type="varchar" jt="12" />
			<index name="pk_public_excluded" unique="PRIMARY_KEY" >
				<column name="column1" />
				<column name="column2" />
			</index>
		</table>
		<table name="foo" >
			<column name="bar" type="varchar" jt="12" mandatory="y" />
			<column name="baz" type="varchar" jt="12" />
			<column name="ignore_me" type="timestamp" jt="93" />
			<index name="pk_test_schema_foo_bar" unique="PRIMARY_KEY" >
				<column name="bar" />
			</index>
		</table>
		<table name="part" >
			<column name="part_id" type="uuid" jt="1111" mandatory="y" >
				<defo><![CDATA[uuid_generate_v1mc()]]></defo>
			</column>
			<column name="part_name" type="varchar" length="100" jt="12" />
			<index name="pk_public_parts_part_id" unique="PRIMARY_KEY" >
				<column name="part_id" />
			</index>
		</table>
		<table name="part_part" >
			<comment><![CDATA[This table represents a many to many nested / recursive relationship. This should result in a repeated message.]]></comment>
			<column name="part_id" type="uuid" jt="1111" mandatory="y" />
			<column name="child_part_id" type="uuid" jt="1111" mandatory="y" />
			<index name="pk_public_part_part" unique="PRIMARY_KEY" >
				<column name="part_id" />
				<column name="child_part_id" />
			</index>
			<fk name="fk_public_part_part_public_part" to_schema="public" to_table="part" >
				<fk_column name="part_id" pk="part_id" />
			</fk>
			<fk name="fk_public_part_part_public_part_0" to_schema="public" to_table="part" >
				<fk_column name="child_part_id" pk="part_id" />
			</fk>
		</table>
		<table name="product" >
			<comment><![CDATA[This table represents a top level entity with an identifying primary key.

#service:product]]></comment>
			<column name="product_id" type="integer" jt="4" mandatory="y" >
				<identity><![CDATA[GENERATED ALWAYS AS IDENTITY]]></identity>
			</column>
			<column name="product_name" type="varchar" length="100" jt="12" />
			<column name="sku" type="varchar" length="100" jt="12" />
			<column name="produced" type="timestamptz" jt="93" mandatory="y" />
			<column name="id" type="int" jt="4" />
			<column name="modified" type="timestamp" jt="93" />
			<index name="pk_public_table_id" unique="PRIMARY_KEY" >
				<column name="product_id" />
			</index>
			<index name="idx_product" unique="NORMAL" >
				<comment><![CDATA[This index will not generate an accessor method.]]></comment>
				<column name="id" />
			</index>
			<index name="lookup_sku" unique="NORMAL" >
				<comment><![CDATA[Any index that is prefixed with 'lookup_' will become an accessor methodin the code generated by go_dbmap.]]></comment>
				<column name="sku" />
			</index>
			<fk name="fk_public_product_test_table_pkey" to_schema="test_schema" to_table="test_table_pkey" >
				<fk_column name="id" pk="id" />
			</fk>
		</table>
		<table name="product_parts" >
			<comment><![CDATA[This table represents a many to many relationship between two different entities.

#service: product]]></comment>
			<column name="product_id" type="int" jt="4" mandatory="y" />
			<column name="part_id" type="uuid" jt="1111" mandatory="y" />
			<index name="pk_public_product_parts" unique="PRIMARY_KEY" >
				<column name="product_id" />
				<column name="part_id" />
			</index>
			<fk name="fk_parts_product" to_schema="public" to_table="product" >
				<fk_column name="product_id" pk="product_id" />
			</fk>
			<fk name="fk_product_parts_part" to_schema="public" to_table="part" >
				<fk_column name="part_id" pk="part_id" />
			</fk>
		</table>
	</schema>
	<schema name="test_schema" >
		<table name="address" >
			<column name="address_id" type="integer" jt="4" mandatory="y" >
				<identity><![CDATA[GENERATED ALWAYS AS IDENTITY]]></identity>
			</column>
			<column name="address1" type="varchar" length="100" jt="12" />
			<column name="address2" type="varchar" length="100" jt="12" />
			<column name="city" type="varchar" jt="12" />
			<column name="state" type="varchar" jt="12" />
			<column name="country" type="char" length="2" jt="1" />
			<column name="postcode" type="varchar" jt="12" />
			<index name="pk_address_address_d" unique="PRIMARY_KEY" >
				<column name="address_id" />
			</index>
		</table>
		<table name="foo" >
			<column name="bar" type="varchar" jt="12" mandatory="y" />
			<column name="baz" type="varchar" jt="12" />
			<index name="pk_test_schema_foo_bar" unique="PRIMARY_KEY" >
				<column name="bar" />
			</index>
		</table>
		<table name="test_table_no_pkey" >
			<comment><![CDATA[This table will enumerate every postgres data type as of 9.5]]></comment>
			<column name="bigint_col" type="bigint" jt="-5" />
			<column name="bigint_array_col" type="bigint[]" jt="2003" />
			<column name="big_serial_col" type="bigserial" jt="-5" />
			<column name="bool_col" type="boolean" jt="-7" />
			<column name="bytea_col" type="bytea" jt="-2" />
			<column name="char_col" type="char" length="100" jt="1" />
			<column name="cidr_col" type="cidr" jt="1111" />
			<column name="date_col" type="date" jt="91" >
				<defo><![CDATA[current_date]]></defo>
			</column>
			<column name="float8_col" type="float8" jt="6" />
			<column name="inet_col" type="inet" jt="1111" />
			<column name="integer_col" type="integer" jt="4" />
			<column name="integer_array_col" type="integer[]" jt="2003" />
			<column name="json_col" type="json" jt="2000" />
			<column name="numeric_precision_col" type="numeric" length="9" decimal="4" jt="2" />
			<column name="numeric_col" type="numeric" jt="2" />
			<column name="real_col" type="real" jt="7" />
			<column name="serial_col" type="serial" jt="4" />
			<column name="smallint_col" type="smallint" jt="5" />
			<column name="smallint_array_col" type="smallint[]" jt="2003" />
			<column name="smallserial_col" type="smallserial" jt="5" />
			<column name="text_col" type="text" jt="12" />
			<column name="time_col" type="time" jt="92" >
				<defo><![CDATA[current_time]]></defo>
			</column>
			<column name="timestamp_col" type="timestamp" jt="93" >
				<defo><![CDATA[current_timestamp]]></defo>
			</column>
			<column name="timestampz_col" type="timestamptz" jt="93" >
				<defo><![CDATA[current_timestamp]]></defo>
			</column>
			<column name="uuid_col" type="uuid" jt="1111" />
			<column name="varchar_col" type="varchar" jt="12" />
			<column name="varchar_length_col" type="varchar" length="256" jt="12" />
			<column name="xml_col" type="xml" jt="2009" />
			<column name="int_col" type="int" jt="4" />
			<column name="decimal_col" type="decimal" jt="3" />
			<column name="jsonb_col" type="jsonb" jt="2000" mandatory="y" />
		</table>
		<table name="test_table_pkey" >
			<comment><![CDATA[This table will enumerate every postgres data type as of 9.5 with a primary key]]></comment>
			<column name="bigint_col" type="bigint" jt="-5" />
			<column name="bigint_array_col" type="bigint[]" jt="2003" />
			<column name="big_serial_col" type="bigserial" jt="-5" />
			<column name="bool_col" type="boolean" jt="-7" />
			<column name="bytea_col" type="bytea" jt="-2" />
			<column name="char_col" type="char" length="100" jt="1" />
			<column name="cidr_col" type="cidr" jt="1111" />
			<column name="date_col" type="date" jt="91" >
				<defo><![CDATA[current_date]]></defo>
			</column>
			<column name="float8_col" type="float8" jt="6" />
			<column name="inet_col" type="inet" jt="1111" />
			<column name="integer_col" type="integer" jt="4" />
			<column name="integer_array_col" type="integer[]" jt="2003" />
			<column name="json_col" type="json" jt="2000" />
			<column name="numeric_precision_col" type="numeric" length="9" decimal="4" jt="2" />
			<column name="numeric_col" type="numeric" jt="2" />
			<column name="real_col" type="real" jt="7" />
			<column name="serial_col" type="serial" jt="4" />
			<column name="smallint_col" type="smallint" jt="5" />
			<column name="smallint_array_col" type="smallint[]" jt="2003" />
			<column name="smallserial_col" type="smallserial" jt="5" />
			<column name="text_col" type="text" jt="12" />
			<column name="time_col" type="time" jt="92" >
				<defo><![CDATA[current_time]]></defo>
			</column>
			<column name="timestamp_col" type="timestamp" jt="93" >
				<defo><![CDATA[current_timestamp]]></defo>
			</column>
			<column name="timestampz_col" type="timestamptz" jt="93" >
				<defo><![CDATA[current_timestamp]]></defo>
			</column>
			<column name="uuid_col" type="uuid" jt="1111" />
			<column name="varchar_col" type="varchar" jt="12" />
			<column name="varchar_length_col" type="varchar" length="256" jt="12" />
			<column name="xml_col" type="xml" jt="2009" />
			<column name="int_col" type="int" jt="4" />
			<column name="decimal_col" type="decimal" jt="3" />
			<column name="id" type="integer" jt="4" mandatory="y" >
				<identity><![CDATA[GENERATED ALWAYS AS IDENTITY]]></identity>
			</column>
			<column name="jsonb_col" type="jsonb" jt="2000" />
			<column name="text_array_col" type="text[]" length="250" jt="2003" />
			<column name="bool_array_col" type="bool[]" jt="2003" />
			<index name="pk_test_table_no_pkey_0_id" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
		</table>
		<table name="user" >
			<comment><![CDATA[This table will help test secondary lookup via email.

#service: user]]></comment>
			<column name="user_id" type="bigint" jt="-5" mandatory="y" >
				<identity><![CDATA[GENERATED BY DEFAULT AS IDENTITY]]></identity>
			</column>
			<column name="first_name" type="varchar" length="100" jt="12" />
			<column name="last_name" type="varchar" length="100" jt="12" />
			<column name="email" type="varchar" jt="12" mandatory="y" />
			<column name="geog" type="geography(point)" jt="1111" />
			<column name="pword_hash" type="bytea" jt="-2" />
			<column name="user_token" type="uuid" jt="1111" mandatory="y" >
				<defo><![CDATA[uuid_generate_v1()]]></defo>
			</column>
			<column name="enabled" type="boolean" jt="-7" mandatory="y" >
				<defo><![CDATA[true]]></defo>
			</column>
			<column name="aka_id" type="bigint" jt="-5" />
			<column name="my_array" type="integer[]" jt="2003" mandatory="y" />
			<column name="user_type" type="varchar" jt="12" mandatory="y" />
			<column name="number_value" type="integer" jt="4" mandatory="y" />
			<column name="created_on" type="timestamp" jt="93" mandatory="y" >
				<defo><![CDATA[current_timestamp]]></defo>
			</column>
			<column name="updated_on" type="timestamp" jt="93" />
			<column name="due_date" type="date" jt="91" />
			<column name="user_state" type="varchar" jt="12" />
			<column name="user_state_type" prior="one_two_three" type="boolean" jt="-7" >
				<defo><![CDATA[true]]></defo>
			</column>
			<index name="lookup_email" unique="UNIQUE_KEY" >
				<comment><![CDATA[Any index that is prefixed with 'lookup_' will become an accessor methodin the code generated by go_dbmap.]]></comment>
				<column name="email" />
			</index>
			<index name="pk_user" unique="PRIMARY_KEY" >
				<column name="user_id" />
			</index>
			<index name="list_by_name" unique="NORMAL" >
				<column name="first_name" />
				<column name="last_name" />
			</index>
			<index name="list_by_enabled" unique="NORMAL" >
				<column name="enabled" />
			</index>
			<index name="list_by_user_type_enabled" unique="NORMAL" >
				<comment><![CDATA[+ORDER BY enabled DESC]]></comment>
				<column name="enabled" />
				<column name="user_type" />
			</index>
			<constraint name="check_user_type" >
				<string><![CDATA[user_type IN ('BIG SHOT', 'LITTLE-SHOT', 'BUSY_GUY', 'BUSYGAL', '123FUN')]]></string>
			</constraint>
			<constraint name="check_user_number_value" >
				<string><![CDATA[number_value > 1]]></string>
			</constraint>
			<constraint name="check_user_state" >
				<string><![CDATA[user_state IN ('unknown', 'living', 'deceased')]]></string>
			</constraint>
			<fk name="fk_user_user" to_schema="test_schema" to_table="user" >
				<fk_column name="aka_id" pk="user_id" />
			</fk>
		</table>
		<table name="user_product_part" >
			<comment><![CDATA[#service: user]]></comment>
			<column name="user_id" type="bigint" jt="-5" mandatory="y" />
			<column name="product_id" type="integer" jt="4" mandatory="y" />
			<column name="part_id" type="uuid" jt="1111" mandatory="y" />
			<column name="inserted_on" type="bigint" jt="-5" mandatory="y" >
				<comment><![CDATA[The UNIX epoch]]></comment>
			</column>
			<index name="pk_user_product_part" unique="PRIMARY_KEY" >
				<column name="user_id" />
				<column name="product_id" />
				<column name="part_id" />
			</index>
			<index name="unq_user_product_part_product_id" unique="UNIQUE_KEY" >
				<column name="product_id" />
			</index>
			<index name="unq_user_product_part_user_id" unique="UNIQUE_KEY" >
				<column name="user_id" />
			</index>
			<fk name="fk_user_product_part_product" to_schema="public" to_table="product" >
				<fk_column name="product_id" pk="product_id" />
			</fk>
			<fk name="fk_user_product_part_user" to_schema="test_schema" to_table="user" >
				<fk_column name="user_id" pk="user_id" />
			</fk>
			<fk name="fk_user_product_part_part" to_schema="public" to_table="part" >
				<fk_column name="part_id" pk="part_id" />
			</fk>
		</table>
	</schema>
	<connector name="PostgreSQL" database="PostgreSQL" driver_class="org.postgresql.Driver" driver_jar="postgresql-42.2.23.jar" driver_desc="Standard" host="localhost" port="5432" instance="proto_crudl" user="proto_crudl" passwd="ZXJsX3Byb3RvZGI=" />
	<layout name="Default Layout" id="Layout_5f168fb" joined_routing="y" show_column_type="y" show_relation="columns" >
		<entity schema="test_schema" name="address" color="C1D8EE" x="160" y="192" />
		<entity schema="public" name="example_a" color="C1D8EE" x="464" y="688" />
		<entity schema="public" name="example_b" color="C1D8EE" x="464" y="448" />
		<entity schema="public" name="example_c" color="C1D8EE" x="192" y="688" />
		<entity schema="public" name="excluded" color="C1D8EE" x="464" y="208" />
		<entity schema="test_schema" name="foo" color="3986C1" x="736" y="688" />
		<entity schema="public" name="foo" color="C1D8EE" x="176" y="496" />
		<entity schema="public" name="part" color="C1D8EE" x="1344" y="192" />
		<entity schema="public" name="part_part" color="C1D8EE" x="1376" y="336" />
		<entity schema="public" name="product" color="C1D8EE" x="1984" y="192" />
		<entity schema="public" name="product_parts" color="C1D8EE" x="1664" y="192" />
		<entity schema="test_schema" name="test_table_no_pkey" color="C1D8EE" x="1376" y="736" />
		<entity schema="test_schema" name="test_table_pkey" color="3986C1" x="976" y="704" />
		<entity schema="test_schema" name="user" color="C1D8EE" x="768" y="128" />
		<entity schema="test_schema" name="user_product_part" color="C1D8EE" x="1344" y="528" />
		<callout x="48" y="48" pointer="Round" >
			<comment><![CDATA[This schema is designed to test the mapping from a SQL Schema 
to Erlang CRUD/L generated code as well as supporting protobuffers.

Currently only Postgres is supported]]></comment>
		</callout>
		<script name="SQL_Editor" id="Editor_18e7824" language="SQL" >
			<string><![CDATA[CREATE SCHEMA IF NOT EXISTS test_schema;

CREATE  TABLE "public".example_a ( 
	column_a             varchar  NOT NULL ,
	column_b             varchar  NOT NULL ,
	column_c             integer   ,
	column_d             integer[]   ,
	column_e             varchar []   ,
	column_f             text[]   ,
	column_g             bool[]   ,
	column_h             json[]   ,
	column_i             varchar  NOT NULL ,
	CONSTRAINT pk_example_a PRIMARY KEY ( column_a, column_b ),
	CONSTRAINT unq_example_a UNIQUE ( column_i ) 
 );

CREATE INDEX idx_example_a ON "public".example_a ( column_c );

COMMENT ON TABLE "public".example_a IS 'If generated by DBSchema, then SQL file needs to be fixed up. The ''[]'' needs to be part of the datatype (no spaces)';

CREATE  TABLE "public".excluded ( 
	column1              integer  NOT NULL ,
	column2              integer  NOT NULL ,
	column3              varchar   ,
	CONSTRAINT pk_public_excluded PRIMARY KEY ( column1, column2 )
 );

CREATE  TABLE "public".foo ( 
	bar                  varchar  NOT NULL ,
	baz                  varchar   ,
	ignore_me            timestamp   ,
	CONSTRAINT pk_test_schema_foo_bar PRIMARY KEY ( bar )
 );

CREATE  TABLE "public".part ( 
	part_id              serial  NOT NULL ,
	part_name            varchar(100)   ,
	CONSTRAINT pk_public_parts_part_id PRIMARY KEY ( part_id )
 );

CREATE  TABLE "public".part_part ( 
	part_id              int  NOT NULL ,
	child_part_id        int  NOT NULL ,
	CONSTRAINT pk_public_part_part PRIMARY KEY ( part_id, child_part_id )
 );

COMMENT ON TABLE "public".part_part IS 'This table represents a many to many nested / recursive relationship. This should result in a repeated message.';

CREATE  TABLE "public".product ( 
	product_id           serial  NOT NULL ,
	product_name         varchar(100)   ,
	sku                  varchar(100)   ,
	produced             timestamptz  NOT NULL ,
	id                   int   ,
	modified             timestamp   ,
	CONSTRAINT pk_public_table_id PRIMARY KEY ( product_id )
 );

CREATE INDEX idx_product ON "public".product ( id );

COMMENT ON INDEX idx_product IS 'This index will not generate an accessor method.';

CREATE INDEX lookup_sku ON "public".product ( sku );

COMMENT ON INDEX lookup_sku IS 'Any index that is prefixed with ''lookup_'' will become an accessor methodin the code generated by go_dbmap.';

COMMENT ON TABLE "public".product IS 'This table represents a top level entity with an identifying primary key.\n\n#service:product';

CREATE  TABLE "public".product_parts ( 
	product_id           int  NOT NULL ,
	part_id              int  NOT NULL ,
	CONSTRAINT pk_public_product_parts PRIMARY KEY ( product_id, part_id )
 );

COMMENT ON TABLE "public".product_parts IS 'This table represents a many to many relationship between two different entities.\n\n#service: product';

CREATE  TABLE "public".example_b ( 
	column_a             varchar  NOT NULL ,
	column_b1            varchar  NOT NULL ,
	column_1             integer  NOT NULL ,
	test_id              integer   ,
	p_bar                varchar   ,
	t_bar                varchar   ,
	CONSTRAINT pk_example_b_column_1 PRIMARY KEY ( column_1 ),
	CONSTRAINT unq_example_b_column_a UNIQUE ( column_a ) 
 );

CREATE INDEX list_by_public_foo ON "public".example_b ( p_bar );

CREATE  TABLE "public".example_c ( 
	column_aa            integer  NOT NULL ,
	column_a             varchar  NOT NULL ,
	CONSTRAINT pk_example_c_column_aa PRIMARY KEY ( column_aa )
 );

COMMENT ON COLUMN "public".example_c.column_a IS 'This shows a weird corner case where a column that is part of a composite foreign key is referencing another table as a single column';

CREATE  TABLE test_schema.address ( 
	address_id           serial  NOT NULL ,
	address1             varchar(100)   ,
	address2             varchar(100)   ,
	city                 varchar   ,
	"state"              varchar   ,
	country              char(2)   ,
	postcode             varchar   ,
	CONSTRAINT pk_address_address_d PRIMARY KEY ( address_id )
 );

CREATE  TABLE test_schema.foo ( 
	bar                  varchar  NOT NULL ,
	baz                  varchar   ,
	CONSTRAINT pk_test_schema_foo_bar PRIMARY KEY ( bar )
 );

CREATE  TABLE test_schema.test_table_no_pkey ( 
	bigint_col           bigint   ,
	bigint_array_col     bigint[]   ,
	big_serial_col       bigserial   ,
	bool_col             bool   ,
	bytea_col            bytea   ,
	char_col             char(100)   ,
	cidr_col             cidr   ,
	date_col             date DEFAULT current_date  ,
	float8_col           float8   ,
	inet_col             inet   ,
	integer_col          integer   ,
	integer_array_col    integer[]   ,
	json_col             json   ,
	numeric_precision_col numeric(9,4)   ,
	numeric_col          numeric   ,
	real_col             real   ,
	serial_col           serial   ,
	smallint_col         smallint   ,
	smallint_array_col   smallint[]   ,
	smallserial_col      smallserial   ,
	text_col             text   ,
	time_col             time DEFAULT current_time  ,
	timestamp_col        timestamp DEFAULT current_timestamp  ,
	timestampz_col       timestamptz DEFAULT current_timestamp  ,
	uuid_col             uuid   ,
	varchar_col          varchar   ,
	varchar_length_col   varchar(256)   ,
	xml_col              xml   ,
	int_col              int   ,
	decimal_col          decimal   ,
	jsonb_col            jsonb  NOT NULL 
 );

COMMENT ON TABLE test_schema.test_table_no_pkey IS 'This table will enumerate every postgres data type as of 9.5';

CREATE  TABLE test_schema.test_table_pkey ( 
	bigint_col           bigint   ,
	bigint_array_col     bigint[]   ,
	big_serial_col       bigserial   ,
	bool_col             bool   ,
	bytea_col            bytea   ,
	char_col             char(100)   ,
	cidr_col             cidr   ,
	date_col             date DEFAULT current_date  ,
	float8_col           float8   ,
	inet_col             inet   ,
	integer_col          integer   ,
	integer_array_col    integer[]   ,
	json_col             json   ,
	numeric_precision_col numeric(9,4)   ,
	numeric_col          numeric   ,
	real_col             real   ,
	serial_col           serial   ,
	smallint_col         smallint   ,
	smallint_array_col   smallint[]   ,
	smallserial_col      smallserial   ,
	text_col             text   ,
	time_col             time DEFAULT current_time  ,
	timestamp_col        timestamp DEFAULT current_timestamp  ,
	timestampz_col       timestamptz DEFAULT current_timestamp  ,
	uuid_col             uuid   ,
	varchar_col          varchar   ,
	varchar_length_col   varchar(256)   ,
	xml_col              xml   ,
	int_col              int   ,
	decimal_col          decimal   ,
	id                   serial  NOT NULL ,
	jsonb_col            jsonb   ,
	text_array_col       text[]   ,
	bool_array_col       bool[]   ,
	CONSTRAINT pk_test_table_no_pkey_0_id PRIMARY KEY ( id )
 );

COMMENT ON TABLE test_schema.test_table_pkey IS 'This table will enumerate every postgres data type as of 9.5 with a primary key';

CREATE  TABLE test_schema."user" ( 
	user_id              serial  NOT NULL ,
	first_name           varchar(100)   ,
	last_name            varchar(100)   ,
	email                varchar  NOT NULL ,
	geog                 geography(point)   ,
	pword_hash           bytea   ,
	user_token           uuid DEFAULT uuid_generate_v1mc() NOT NULL ,
	enabled              bool DEFAULT true NOT NULL ,
	aka_id               int   ,
	my_array             integer[]  NOT NULL ,
	user_type            varchar  NOT NULL ,
	number_value         integer  NOT NULL ,
	created_on           timestamp  NOT NULL ,
	updated_on           timestamp   ,
	due_date             date   ,
	CONSTRAINT lookup_email UNIQUE ( email ) ,
	CONSTRAINT pk_user PRIMARY KEY ( user_id )
 );

ALTER TABLE test_schema."user" ADD CONSTRAINT check_user_type CHECK ( user_type IN ('BIG SHOT', 'LITTLE-SHOT', 'BUSY_GUY', 'BUSYGAL', '123FUN') );

ALTER TABLE test_schema."user" ADD CONSTRAINT check_user_number_value CHECK ( number_value > 1 );

COMMENT ON CONSTRAINT lookup_email ON test_schema."user" IS 'Any index that is prefixed with ''lookup_'' will become an accessor methodin the code generated by go_dbmap.';

CREATE INDEX list_by_name ON test_schema."user" ( first_name, last_name );

CREATE INDEX list_by_enabled ON test_schema."user" ( enabled );

CREATE INDEX list_by_user_type_enabled ON test_schema."user" ( user_type, enabled );

COMMENT ON INDEX list_by_user_type_enabled IS '+ORDER BY enabled DESC';

COMMENT ON TABLE test_schema."user" IS 'This table will help test secondary lookup via email.\n\n#service: user';

CREATE  TABLE test_schema.user_product_part ( 
	user_id              integer  NOT NULL ,
	product_id           integer  NOT NULL ,
	part_id              integer  NOT NULL ,
	inserted_on          bigint  NOT NULL ,
	CONSTRAINT pk_user_product_part PRIMARY KEY ( user_id, product_id, part_id ),
	CONSTRAINT unq_user_product_part_product_id UNIQUE ( product_id ) ,
	CONSTRAINT unq_user_product_part_user_id UNIQUE ( user_id ) 
 );

COMMENT ON TABLE test_schema.user_product_part IS '#service: user';

COMMENT ON COLUMN test_schema.user_product_part.inserted_on IS 'The UNIX epoch';

ALTER TABLE "public".example_b ADD CONSTRAINT fk_example_b_example_a FOREIGN KEY ( column_a, column_b1 ) REFERENCES "public".example_a( column_a, column_b );

ALTER TABLE "public".example_b ADD CONSTRAINT fk_example_b_test_table_pkey FOREIGN KEY ( test_id ) REFERENCES test_schema.test_table_pkey( id );

ALTER TABLE "public".example_b ADD CONSTRAINT fk_example_b_pfoo FOREIGN KEY ( p_bar ) REFERENCES "public".foo( bar );

ALTER TABLE "public".example_b ADD CONSTRAINT fk_example_b_tfoo FOREIGN KEY ( t_bar ) REFERENCES test_schema.foo( bar );

ALTER TABLE "public".example_c ADD CONSTRAINT fk_example_c_example_b FOREIGN KEY ( column_a ) REFERENCES "public".example_b( column_a );

ALTER TABLE "public".part_part ADD CONSTRAINT fk_public_part_part_public_part FOREIGN KEY ( part_id ) REFERENCES "public".part( part_id );

ALTER TABLE "public".part_part ADD CONSTRAINT fk_public_part_part_public_part_0 FOREIGN KEY ( child_part_id ) REFERENCES "public".part( part_id );

ALTER TABLE "public".product ADD CONSTRAINT fk_public_product_test_table_pkey FOREIGN KEY ( id ) REFERENCES test_schema.test_table_pkey( id );

ALTER TABLE "public".product_parts ADD CONSTRAINT fk_parts_product FOREIGN KEY ( product_id ) REFERENCES "public".product( product_id );

ALTER TABLE "public".product_parts ADD CONSTRAINT fk_product_parts_part FOREIGN KEY ( part_id ) REFERENCES "public".part( part_id );

ALTER TABLE test_schema."user" ADD CONSTRAINT fk_user_user FOREIGN KEY ( aka_id ) REFERENCES test_schema."user"( user_id );

ALTER TABLE test_schema.user_product_part ADD CONSTRAINT fk_user_product_part_product FOREIGN KEY ( product_id ) REFERENCES "public".product( product_id );

ALTER TABLE test_schema.user_product_part ADD CONSTRAINT fk_user_product_part_user FOREIGN KEY ( user_id ) REFERENCES test_schema."user"( user_id );

ALTER TABLE test_schema.user_product_part ADD CONSTRAINT fk_user_product_part_part FOREIGN KEY ( part_id ) REFERENCES "public".part( part_id );
]]></string>
		</script>
	</layout>
</project>