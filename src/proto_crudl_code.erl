%%%-------------------------------------------------------------------
%%% @author bryan
%%% @copyright (C) 2021, <COMPANY>
%%% @doc
%%%
%%% NOTE: if you are using records ang GPB, then GPB will write out the include files
%%%
%%% @end
%%% Created : 04. Feb 2021 12:18 PM
%%%-------------------------------------------------------------------
-module(proto_crudl_code).
-author("bryan").

%% API
-export([generate/3, build_enum_case/1, is_version/2]).

-include("proto_crudl.hrl").

-spec generate([{atom(), any()}], [{atom(), string()}], #database{}) -> ok | {error, Reason :: any()}.
generate(ProviderConfig, OutputConfig, Database = #database{tables = TableDict}) ->
    io:format("~n------- Generating Erlang Code --------~n"),
    Provider = proplists:get_value(provider, ProviderConfig),
    SourcePath = proplists:get_value(source_path, OutputConfig, "src"),
    Suffix = proplists:get_value(suffix, OutputConfig, "_db"),
    UseRecords = proplists:get_value(use_records, OutputConfig, true),
    UsePackage = proplists:get_value(use_package, OutputConfig, false),
    UseGpb = proplists:get_value(use_gpb, OutputConfig, true),
    Tables = proto_crudl_queries:build_queries(dict:to_list(TableDict), []),
    generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, Tables).


generate_sources(_Provider, _SourcePath, _Suffix, _UseRecords, _UsePackage, _UseGpb, _Database, []) ->
    ok;
generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, [{_Key, Table} | Rest]) ->
    S = proto_crudl_utils:to_string(Table#table.schema),
    N = proto_crudl_utils:to_string(Table#table.name),
    ModuleName = case UsePackage of true -> S ++ "_" ++ N ++ Suffix; _ -> N ++ Suffix end,
    Header = "%%-------------------------------------------------------------------\n"
             "%% This file is automatically generated from the database schema.\n"
             "%% ---- DO NOT MAKE CHANGES DIRECTLY TO THIS FILE! ----\n\n"
             "-module(" ++ ModuleName ++ ").\n\n",

    FullPath = filename:join([SourcePath, [ModuleName, ".erl"]]),
    case filelib:ensure_dir(FullPath) of
        ok -> ok;
        {error, eexist} -> ok;
        {error, eacces} ->
            io:format("Missing search or write permissions for the parent directories of ~p~n", [FullPath]),
            exit(eaccess);
        {error, enoent} ->
            io:format("A component of ~p does not exist~n", [FullPath]),
            exit(enoent);
        {error, enospc} ->
            io:format("No space is left on the device~n", []),
            exit(enospc);
        {error, enotdir} ->
            io:format("A component of ~p is not a directory. On some platforms, enoent is returned instead~n",
                      [FullPath]),
            exit(enotdir)
    end,

    ok = file:write_file(FullPath, Header, [write]),

    % Generate our SQL defines for INSERT, SELECT, UPDATE, DELETE, LOOKUP, and custom mappings
    generate_defines(FullPath, Table),

    % Generate any enumerations
    generate_enums(FullPath, orddict:to_list(Table#table.columns)),

    case UseGpb of true -> file:write_file(FullPath, "\n% {use_gpb, true}\n-include(\"" ++ N ++ "_pb.hrl\").\n", [append]); _ -> ok end,

    % Generate the map or record functions and maybe the record
    case {UseRecords, UseGpb} of
        {true, true} ->
            io:format("~p (using_records)~n", [FullPath]),
            generate_exports(use_records, FullPath, Table),
            proto_crudl_records:generate_functions(Provider, FullPath, UsePackage, Table);
        {true, false} ->
            io:format("~p (using_records)~n", [FullPath]),
            generate_exports(use_records, FullPath, Table),
            generate_record(FullPath, UsePackage, Table),
            proto_crudl_records:generate_functions(Provider, FullPath, UsePackage, Table);
        _ ->
            io:format("~p (using_maps)~n", [FullPath]),
            generate_exports(use_maps, FullPath, Table),
            proto_crudl_maps:generate_functions(Provider, FullPath, Table)
    end,

    % Generate enum helpers
    generate_enum_helpers(FullPath, orddict:to_list(Table#table.columns)),

    generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, Rest).


generate_record(FullPath, UsePackage, #table{schema = S, name = T, select_list = SL, columns = ColDict}) ->
    RecordStr = case UsePackage of true ->
                        "-record('" ++ proto_crudl_utils:to_string(S) ++ "." ++ proto_crudl_utils:camel_case(T) ++ "', {";
                    _ ->
                        "-record('" ++ proto_crudl_utils:camel_case(T) ++ "', {"
                end,
    StrLen = string:length(RecordStr),
    ok = file:write_file(FullPath, "\n% {inline_record, true}\n", [append]),
    ok = file:write_file(FullPath, RecordStr, [append]),
    Lines = lists:join(",\n", write_record_fields(FullPath, 0, StrLen, SL, ColDict, [])),
    ok = file:write_file(FullPath, Lines, [append]),
    ok = file:write_file(FullPath, "}).\n\n", [append]).


write_record_fields(_FullPath, _Cnt, _StrLen, [], _ColDict, Acc) ->
    lists:reverse(Acc);
write_record_fields(FullPath, 0, StrLen, [ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    CName = proto_crudl_utils:to_string(Column#column.name),
    UdtName = proto_crudl_psql:sql_to_erlang_datatype(Column#column.udt_name),
    Line = case Column#column.data_type of
        <<"ARRAY">> ->
            CName ++ " = [] :: [" ++ UdtName ++ "()]";
        _->
            CName ++ " :: " ++ UdtName ++ "() | undefined"
    end,
    write_record_fields(FullPath, 1, StrLen, Rest, ColDict, [Line | Acc]);
write_record_fields(FullPath, Cnt, StrLen, [ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    Tab = [" " || _Cnt <- lists:seq(1, StrLen)],
    CName = proto_crudl_utils:to_string(Column#column.name),
    UdtName = proto_crudl_psql:sql_to_erlang_datatype(Column#column.udt_name),
    Line = case Column#column.data_type of
               <<"ARRAY">> ->
                   Tab ++ CName ++ " = [] :: [" ++ UdtName ++ "()]";
               _->
                   Tab ++ CName ++ " :: " ++ UdtName ++ "() | undefined"
           end,
    write_record_fields(FullPath, Cnt + 1, StrLen, Rest, ColDict, [Line | Acc]).


generate_defines(FullPath, #table{query_dict = QD}) ->
    Fun = fun(_Key, #query{name = N, query = Q}, _Acc) ->
                ok = file:write_file(FullPath, "-define(" ++ N ++ ", \"" ++ Q ++ "\").\n", [append])
          end,
    orddict:fold(Fun, [], QD).


-spec generate_enums(string(), list({binary(), #column{}})) -> string().
generate_enums(_FullPath, []) ->
    ok;
generate_enums(FullPath, [{_Key, #column{name = Name, valid_values = VV}} | Rest]) when length(VV) > 0 ->
    ok = file:write_file(FullPath, io_lib:format("\n% ~p enums\n", [Name]), [append]),
    EnumMapStr = lists:join(", ", [io_lib:format("'~s' => <<\"~s\">>", [proto_crudl_proto:make_enum_label(V), proto_crudl_utils:to_string(V)]) || V <- VV]),
    file:write_file(FullPath, io_lib:format("-define(~s_ENUMS, #{~s}).\n", [proto_crudl_utils:camel_case(Name), EnumMapStr]), [append]),

    ValueMapStr = lists:join(", ", [io_lib:format("<<\"~s\">> => '~s'", [proto_crudl_utils:to_string(V), proto_crudl_proto:make_enum_label(V)]) || V <- VV]),
    file:write_file(FullPath, io_lib:format("-define(~s_VALUES, #{~s}).\n", [proto_crudl_utils:camel_case(Name), ValueMapStr]), [append]),
    generate_enums(FullPath, Rest);
generate_enums(FullPath, [_Head | Rest]) ->
    generate_enums(FullPath, Rest).


-spec generate_enum_helpers(string(), list({binary(), #column{}})) -> string().
generate_enum_helpers(_FullPath, []) ->
    ok;
generate_enum_helpers(FullPath, [{_Key, #column{name = Name, valid_values = VV}} | Rest]) when length(VV) > 0 ->
    ok = file:write_file(FullPath, io_lib:format("\n~s_enum(Value) ->\n", [Name]), [append]),
    ok = file:write_file(FullPath, io_lib:format("    maps:get(Value, ?~s_VALUES, null).\n", [proto_crudl_utils:camel_case(Name)]), [append]),

    ok = file:write_file(FullPath, io_lib:format("\n~s_value(Enum) ->\n", [Name]), [append]),
    ok = file:write_file(FullPath, io_lib:format("    maps:get(Enum, ?~s_ENUMS, null).\n", [proto_crudl_utils:camel_case(Name)]), [append]),
    generate_enum_helpers(FullPath, Rest);
generate_enum_helpers(FullPath, [_Head | Rest]) ->
    generate_enum_helpers(FullPath, Rest).


generate_exports(RecordsOrMaps, FullPath, Table = #table{query_dict = QD}) ->
    ok = file:write_file(FullPath, "\n%% API\n", [append]),
    case RecordsOrMaps of
        use_maps ->
            ok = file:write_file(FullPath, "-export([from_proto/1,\n"
                                           "         to_proto/1,\n"
                                           "         new/0,\n", [append]);
        _ ->
            ok = file:write_file(FullPath, "-export([from_proto/1,\n"
                                           "         to_proto/1,\n"
                                           "         new/0,\n", [append])
    end,

    Queries = orddict:to_list(QD),
    Fun0 = fun({_Key, #query{fun_name = FN, fun_args = FA}}, Acc) ->
                ["         " ++ FN ++ "/" ++ FA | Acc]
           end,
    [ok = file:write_file(FullPath, Line, [append]) || Line <- lists:join(",\n", lists:foldl(Fun0, [], Queries))],

    case ["         " ++ atom_to_list(FunName) ++ "/" ++ integer_to_list(proto_crudl_psql:count_params(FunSql))
          || {FunName, #custom_query{query = FunSql}} <- Table#table.mappings] of
        [] ->
            ok;
        Mappings ->
            ok = file:write_file(FullPath, ",\n", [append]),
            ok = file:write_file(FullPath, lists:join(",\n", Mappings), [append])
    end,

    ColumnList = orddict:to_list(Table#table.columns),
    Fun1 = fun({_Key, Column}, Acc) ->
                case length(Column#column.valid_values) of
                    0 ->
                        Acc;
                    _ ->
                        ["         " ++ proto_crudl_utils:to_string(Column#column.name) ++ "_enum/1,\n" ++
                         "         " ++ proto_crudl_utils:to_string(Column#column.name) ++ "_value/1" | Acc]
                end
          end,
    Lines = lists:join(",\n", lists:foldl(Fun1, [], ColumnList)),
    case length(Lines) of L when L > 0 -> ok = file:write_file(FullPath, ",\n", [append]); _ -> ok end,
    [ok = file:write_file(FullPath, Line, [append]) || Line <- Lines],

    case Table#table.has_arrays of
        true ->
            ok = file:write_file(FullPath, ",\n         ensure_array/1", [append]);
        _ ->
            ok
    end,

    case Table#table.has_dates of
        true ->
            ok = file:write_file(FullPath, ",\n         date_encode/1,\n"
                                           "         date_decode/1", [append]);
        _ ->
            ok
    end,

    case Table#table.has_timestamps of
        true ->
            ok = file:write_file(FullPath, ",\n         ts_encode/1,\n"
                                           "         ts_decode/1", [append]);
        _ ->
            ok
    end,
    ok = file:write_file(FullPath, "]).\n\n", [append]).

-spec is_version(orddict:dict(), binary()) -> boolean().
is_version(ColDict, C) when is_binary(C) ->
    Column = orddict:fetch(C, ColDict),
    Column#column.is_version.

-spec build_enum_case(#table{}) -> string().
build_enum_case(#table{columns = ColDict}) ->
    build_enum_cases(orddict:to_list(ColDict), "").

build_enum_cases([], Acc) ->
    Acc;
build_enum_cases([{_Key, #column{name = N, valid_values = VV}} | Rest], Acc) when length(VV) > 0 ->
    Name = proto_crudl_utils:camel_case(N),
    UpperSnakeCase = proto_crudl_utils:capitalize(Name),
    Len = length(Name) + 12,
    Str = "    " ++ Name ++ "Value = case maps:get(" ++ Name ++ ", ?" ++ UpperSnakeCase ++ "_ENUMS) of\n" ++
          proto_crudl_utils:spaces(Len + 4) ++ "{badkey, Key} ->\n" ++
          proto_crudl_utils:spaces(Len + 8) ++ "{error, {badkey, Key}};\n" ++
          proto_crudl_utils:spaces(Len + 4) ++ "Value__ ->\n" ++
          proto_crudl_utils:spaces(Len + 8) ++ "Value__\n" ++
          proto_crudl_utils:spaces(Len) ++ "end,\n",
    build_enum_cases(Rest, [Str, Acc]);
build_enum_cases([_Head | Rest], Acc) ->
    build_enum_cases(Rest, Acc).

%%
%% Tests
%%
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-include_lib("kernel/include/logger.hrl").

-define(DROP_DB, "DROP DATABASE proto_crudl").
-define(CREATE_DB, "CREATE DATABASE proto_crudl WITH OWNER = proto_crudl ENCODING = 'UTF8' TEMPLATE = template0 CONNECTION LIMIT = -1").

first_test() ->
    logger:set_primary_config(level, info),
    ok.



cleanup_version(_C, []) ->
    ok;
cleanup_version(C, [{_Key, T0} | Rest]) ->
    Alter = "ALTER TABLE " ++ binary_to_list(T0#table.schema) ++ "." ++ binary_to_list(T0#table.name) ++
                                                                        " DROP COLUMN version",
    case epgsql:squery(C, Alter) of
        {ok, _Fields, _Rows} ->
            cleanup_version(C, Rest);
        {error, Reason} ->
            io:format("    WARNING: Failed to get alter table ~p.~p. Reason=~p, Stmt=~p~n",
                      [T0#table.schema, T0#table.name, Reason, Alter]),
            ok
    end.

last_test() ->
    ?LOG_INFO("====================== CLEANING UP VERSION COLUMNS ======================"),

    {ok, C} = epgsql:connect(#{host => "localhost",
                               port => 5432,
                               username => "proto_crudl",
                               password => "proto_crudl",
                               database => "proto_crudl",
                               timeout => 4000}),

    {ok, Database} = proto_crudl_psql:read_database(C, [{schemas, ["public", "test_schema"]},
                                                        {excluded, ["public.excluded", "spatial_ref_sys"]}]),

    TablesDict = Database#database.tables,
    ok = cleanup_version(C, dict:to_list(TablesDict)),
    ok = epgsql:close(C).

-endif.
