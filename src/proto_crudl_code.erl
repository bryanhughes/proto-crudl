%%%-------------------------------------------------------------------
%%% @author bryan
%%% @copyright (C) 2021, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 04. Feb 2021 12:18 PM
%%%-------------------------------------------------------------------
-module(proto_crudl_code).
-author("bryan").

%% API
-export([generate/3, build_insert_map/1, build_insert_params/1, build_select_map/1, build_select_params/1,
         build_update_map/1, build_update_params/1, build_delete_map/1, build_delete_params/1,
         build_lookup_list_map/2, build_list_params/1, build_lookup_params/1, build_update_record/2,
         build_insert_record/2, build_select_record/2, build_delete_record/2, build_enum_case/1]).

-include("proto_crudl.hrl").

-spec generate([{atom(), any()}], [{atom(), string()}], #database{}) -> ok | {error, Reason :: any()}.
generate(ProviderConfig, OutputConfig, Database = #database{tables = TableDict}) ->
    io:format("~n------- Generating Erlang Code --------~n"),
    Provider = proplists:get_value(provider, ProviderConfig),
    SourcePath = proplists:get_value(source_path, OutputConfig, "src"),
    Suffix = proplists:get_value(suffix, OutputConfig, "_db"),
    UseRecords = proplists:get_value(use_records, OutputConfig, true),
    UsePackage = proplists:get_value(use_package, OutputConfig, false),
    UseGpb = proplists:get_value(use_gpb, OutputConfig, true),
    Tables = lists:reverse(dict:to_list(TableDict)),
    generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, Tables).


generate_sources(_Provider, _SourcePath, _Suffix, _UseRecords, _UsePackage, _UseGpb, _Database, []) ->
    ok;
generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, [{_Key, Table} | Rest]) ->
    S = proto_crudl_utils:to_string(Table#table.schema),
    N = proto_crudl_utils:to_string(Table#table.name),
    ModuleName = case UsePackage of true -> S ++ "_" ++ N ++ Suffix; _ -> N ++ Suffix end,
    Header = "%%-------------------------------------------------------------------\n"
             "%% This file is automatically generated from the database schema.\n"
             "%% ---- DO NOT MAKE CHANGES DIRECTLY TO THIS FILE! ----\n\n"
             "-module(" ++ ModuleName ++ ").\n\n",

    FullPath = filename:join([SourcePath, [ModuleName, ".erl"]]),
    case filelib:ensure_dir(FullPath) of
        ok -> ok;
        {error, eexist} -> ok;
        {error, eacces} ->
            io:format("Missing search or write permissions for the parent directories of ~p~n", [FullPath]),
            exit(eaccess);
        {error, enoent} ->
            io:format("A component of ~p does not exist~n", [FullPath]),
            exit(enoent);
        {error, enospc} ->
            io:format("No space is left on the device~n", []),
            exit(enospc);
        {error, enotdir} ->
            io:format("A component of ~p is not a directory. On some platforms, enoent is returned instead~n",
                      [FullPath]),
            exit(enotdir)
    end,

    ok = file:write_file(FullPath, Header, [write]),

    % Generate our SQL defines for INSERT, SELECT, UPDATE, DELETE, LOOKUP, and custom mappings
    generate_defines(FullPath, S, N, Table),

    % Generate any enumerations
    generate_enums(FullPath, orddict:to_list(Table#table.columns)),

    case UseGpb of true -> file:write_file(FullPath, "\n% {use_gpb, true}\n-include(\"" ++ N ++ "_pb.hrl\").\n", [append]); _ -> ok end,

    % Generate the map or record functions and maybe the record
    case {UseRecords, UseGpb} of
        {true, true} ->
            io:format("~p (using_records)~n", [FullPath]),
            generate_exports(use_records, FullPath, Table),
            proto_crudl_records:generate_functions(Provider, FullPath, UsePackage, Table);
        {true, false} ->
            io:format("~p (using_records)~n", [FullPath]),
            generate_exports(use_records, FullPath, Table),
            generate_record(FullPath, UsePackage, Table),
            proto_crudl_records:generate_functions(Provider, FullPath, UsePackage, Table);
        _ ->
            io:format("~p (using_maps)~n", [FullPath]),
            generate_exports(use_maps, FullPath, Table),
            proto_crutl_maps:generate_functions(Provider, FullPath, Table)
    end,

    % Generate enum helpers
    generate_enum_helpers(FullPath, orddict:to_list(Table#table.columns)),

    generate_sources(Provider, SourcePath, Suffix, UseRecords, UsePackage, UseGpb, Database, Rest).


generate_record(FullPath, UsePackage, #table{schema = S, name = T, select_list = SL, columns = ColDict}) ->
    RecordStr = case UsePackage of true ->
                        "-record('" ++ proto_crudl_utils:to_string(S) ++ "." ++ proto_crudl_utils:camel_case(T) ++ "', {";
                    _ ->
                        "-record('" ++ proto_crudl_utils:camel_case(T) ++ "', {"
                end,
    StrLen = string:length(RecordStr),
    ok = file:write_file(FullPath, "\n% {inline_record, true}\n", [append]),
    ok = file:write_file(FullPath, RecordStr, [append]),
    Lines = lists:join(",\n", write_record_fields(FullPath, 0, StrLen, SL, ColDict, [])),
    ok = file:write_file(FullPath, Lines, [append]),
    ok = file:write_file(FullPath, "}).\n\n", [append]).


write_record_fields(_FullPath, _Cnt, _StrLen, [], _ColDict, Acc) ->
    lists:reverse(Acc);
write_record_fields(FullPath, 0, StrLen, [ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    CName = proto_crudl_utils:to_string(Column#column.name),
    UdtName = proto_crudl_psql:sql_to_erlang_datatype(Column#column.udt_name),
    Line = case Column#column.data_type of
        <<"ARRAY">> ->
            CName ++ " = [] :: [" ++ UdtName ++ "()]";
        _->
            CName ++ " :: " ++ UdtName ++ "() | undefined"
    end,
    write_record_fields(FullPath, 1, StrLen, Rest, ColDict, [Line | Acc]);
write_record_fields(FullPath, Cnt, StrLen, [ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    Tab = [" " || _Cnt <- lists:seq(1, StrLen)],
    CName = proto_crudl_utils:to_string(Column#column.name),
    UdtName = proto_crudl_psql:sql_to_erlang_datatype(Column#column.udt_name),
    Line = case Column#column.data_type of
               <<"ARRAY">> ->
                   Tab ++ CName ++ " = [] :: [" ++ UdtName ++ "()]";
               _->
                   Tab ++ CName ++ " :: " ++ UdtName ++ "() | undefined"
           end,
    write_record_fields(FullPath, Cnt + 1, StrLen, Rest, ColDict, [Line | Acc]).


generate_defines(FullPath, S, N, Table) ->
    SelectWLimitStr = build_select_with_limit_sql(S, N, Table),
    ok = file:write_file(FullPath, "-define(SELECT_WITH_LIMIT, \"" ++ SelectWLimitStr ++ "\").\n", [append]),
    case Table#table.pkey_list of
        [] ->
            ok;
        _PKeys ->
            SelectStr = build_select_sql(S, N, Table),
            ok = file:write_file(FullPath, "-define(SELECT, \"" ++ SelectStr ++ "\").\n", [append])
    end,
    InsertStr = build_insert_sql(S, N, Table),
    ok = file:write_file(FullPath, "-define(INSERT, \"" ++ InsertStr ++ "\").\n", [append]),
    case Table#table.default_list of
        [] ->
            ok;
        _ ->
            InsertDefaultsStr = build_insert_defaults_sql(S, N, Table),
            ok = file:write_file(FullPath, "-define(INSERT_DEFAULTS, \"" ++ InsertDefaultsStr ++ "\").\n", [append])
    end,
    case Table#table.pkey_list of
        [] ->
            ok;
        _ ->
            UpdateStr = build_update_sql(S, N, Table),
            ok = file:write_file(FullPath, "-define(UPDATE, \"" ++ UpdateStr ++ "\").\n", [append])
    end,
    case Table#table.pkey_list of
        [] ->
            ok;
        _ ->
            DeleteStr = build_delete_sql(S, N, Table),
            ok = file:write_file(FullPath, "-define(DELETE, \"" ++ DeleteStr ++ "\").\n\n", [append])
    end,
    [ok = file:write_file(FullPath, "-define(" ++ proto_crudl_utils:to_string(LookupName) ++ ", \"" ++ LookupStr ++ "\").\n",
                          [append]) || {LookupName, LookupStr} <- build_lookup_list_sql(Table)],
    ok = file:write_file(FullPath, "\n", [append]),

    [ok = file:write_file(FullPath, "-define(" ++ string:to_upper(atom_to_list(FunName)) ++ ", \"" ++
                                    maybe_expand_all(Table, FunSql) ++ "\").\n",
                          [append]) || {FunName, FunSql} <- Table#table.mappings].


-spec generate_enums(string(), list({binary(), #column{}})) -> string().
generate_enums(_FullPath, []) ->
    ok;
generate_enums(FullPath, [{_Key, #column{name = Name, valid_values = VV}} | Rest]) when length(VV) > 0 ->
    ok = file:write_file(FullPath, io_lib:format("\n% ~p enums\n", [Name]), [append]),
    EnumMapStr = lists:join(", ", [io_lib:format("'~s' => <<\"~s\">>", [proto_crudl_proto:make_enum_label(V), proto_crudl_utils:to_string(V)]) || V <- VV]),
    file:write_file(FullPath, io_lib:format("-define(~s_ENUMS, #{~s}).\n", [proto_crudl_utils:camel_case(Name), EnumMapStr]), [append]),

    ValueMapStr = lists:join(", ", [io_lib:format("<<\"~s\">> => '~s'", [proto_crudl_utils:to_string(V), proto_crudl_proto:make_enum_label(V)]) || V <- VV]),
    file:write_file(FullPath, io_lib:format("-define(~s_VALUES, #{~s}).\n", [proto_crudl_utils:camel_case(Name), ValueMapStr]), [append]),
    generate_enums(FullPath, Rest);
generate_enums(FullPath, [_Head | Rest]) ->
    generate_enums(FullPath, Rest).


-spec generate_enum_helpers(string(), list({binary(), #column{}})) -> string().
generate_enum_helpers(_FullPath, []) ->
    ok;
generate_enum_helpers(FullPath, [{_Key, #column{name = Name, valid_values = VV}} | Rest]) when length(VV) > 0 ->
    ok = file:write_file(FullPath, io_lib:format("\n~s_enum(Value) ->\n", [Name]), [append]),
    ok = file:write_file(FullPath, io_lib:format("    maps:get(Value, ?~s_VALUES, undefined).\n", [proto_crudl_utils:camel_case(Name)]), [append]),

    ok = file:write_file(FullPath, io_lib:format("\n~s_value(Enum) ->\n", [Name]), [append]),
    ok = file:write_file(FullPath, io_lib:format("    maps:get(Enum, ?~s_ENUMS, undefined).\n", [proto_crudl_utils:camel_case(Name)]), [append]),
    generate_enum_helpers(FullPath, Rest);
generate_enum_helpers(FullPath, [_Head | Rest]) ->
    generate_enum_helpers(FullPath, Rest).


generate_exports(RecordsOrMaps, FullPath, Table) ->
    ok = file:write_file(FullPath, "\n%% API\n", [append]),
    case RecordsOrMaps of
        use_maps ->
            ok = file:write_file(FullPath, "-export([from_proto/1,\n"
                                           "         to_proto/1,\n"
                                           "         new/0,\n"
                                           "         create/1,\n", [append]);
        _ ->
            ok = file:write_file(FullPath, "-export([new/0,\n"
                                           "         create/1,\n", [append])
    end,
    case Table#table.pkey_list of
        [] ->
            ok;
        _ ->
            ok = file:write_file(FullPath, "         read_or_create/1,\n"
                                           "         read/1,\n"
                                           "         update/1,\n"
                                           "         delete/1,\n", [append])
    end,

    case ["         " ++ proto_crudl_utils:to_string(Idx#index.name) ++ "/1"
          || Idx <- Table#table.indexes, Idx#index.is_lookup == true] of
        [] ->
            ok;
        Lookups ->
            ok = file:write_file(FullPath, lists:join(",\n", Lookups), [append]),
            ok = file:write_file(FullPath, ",\n", [append])
    end,

    case ["         " ++ proto_crudl_utils:to_string(Idx#index.name) ++ "/3"
          || Idx <- Table#table.indexes, Idx#index.is_list == true] of
        [] ->
            ok;
        Lists ->
            ok = file:write_file(FullPath, lists:join(",\n", Lists), [append]),
            ok = file:write_file(FullPath, ",\n", [append])
    end,

    case ["         " ++ atom_to_list(FunName) ++ "/" ++ integer_to_list(proto_crudl_psql:count_params(FunSql))
          || {FunName, FunSql} <- Table#table.mappings] of
        [] ->
            ok;
        Mappings ->
            ok = file:write_file(FullPath, lists:join(",\n", Mappings), [append]),
            ok = file:write_file(FullPath, ",\n", [append])
    end,

    case Table#table.has_timestamps of
        true ->
            ok = file:write_file(FullPath, "         ts_encode_map/1,\n"
                                           "         ts_decode_map/1,\n", [append]);
        _ ->
            ok
    end,

    ColumnList = orddict:to_list(Table#table.columns),
    Fun = fun({_Key, Column}, Acc) ->
                case length(Column#column.valid_values) of
                    0 ->
                        Acc;
                    _ ->
                        ["         " ++ proto_crudl_utils:to_string(Column#column.name) ++ "_enum/1,\n" ++
                         "         " ++ proto_crudl_utils:to_string(Column#column.name) ++ "_value/1,\n" | Acc]
                end
          end,
    [ok = file:write_file(FullPath, Line, [append]) || Line <- lists:join(",\n", lists:foldl(Fun, [], ColumnList))],

    ok = file:write_file(FullPath, "         list/2]).\n\n", [append]).


is_lookuplist(#index{is_lookup = true}) ->
    true;
is_lookuplist(#index{is_list = true}) ->
    true;
is_lookuplist(_) ->
    false.


%% ---- SELECT ----

-spec build_select_with_limit_sql(Schema :: string(), Name :: string(), Table :: #table{}) -> SelectStmt :: string().
%% @doc This function will return the SELECT WITH LIMIT statement based on the applied excluded columns and transformations
build_select_with_limit_sql(Schema, Name, #table{columns = ColDict, select_list = SelectList}) ->
    logger:info("Schema=~p, Table=~p", [Schema, Name]),
    % Now build our select clause using all the columns except those that are excluded
    Clause1 = build_select_clause(SelectList, ColDict, []),
    Clause2 = build_select_xforms(SelectList, ColDict, []),
    lists:flatten("SELECT " ++ lists:join(", ", lists:append(Clause1, Clause2)) ++
                  " FROM " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                  " LIMIT $1 OFFSET $2").


-spec build_select_sql(Schema :: string(), Name :: string(), Table :: #table{}) -> SelectStmt :: string().
%% @doc This function will return the SELECT statement based on the applied excluded columns and transformations
build_select_sql(Schema, Name, Table) ->
    ColDict = Table#table.columns,
    SelectList = Table#table.select_list,
    logger:info("Schema=~p, Table=~p", [Schema, Name]),
    case Table#table.pkey_list of
        [] ->
            "";
        PKColumns ->
            {_Cnt, PKColumns1} = bind_select_params(1, PKColumns, []),

            % Now build our select clause using all the columns except those that are excluded
            Clause1 = build_select_clause(SelectList, ColDict, []),
            Clause2 = build_select_xforms(SelectList, ColDict, []),

            lists:flatten("SELECT " ++ lists:join(", ", lists:append(Clause1, Clause2)) ++
                          " FROM " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                          " WHERE " ++ lists:join(" AND ", PKColumns1))
    end.

build_select_clause([], _ColDict, Acc) ->
    lists:reverse(Acc);
build_select_clause([ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    case Column#column.data_type of
        <<"virtual">> ->
            build_select_clause(Rest, ColDict, Acc);
        _ ->
            build_select_clause(Rest, ColDict, [proto_crudl_utils:to_string(ColumnName) | Acc])
    end.


build_select_xforms([], _ColDict, Acc) ->
    lists:reverse(Acc);
build_select_xforms([ColumnName | Rest], ColDict, Acc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    case Column#column.select_xform of
        undefined ->
            build_select_xforms(Rest, ColDict, Acc);
        Operation ->
            build_select_xforms(Rest, ColDict,
                                [proto_crudl_utils:to_string(Operation) ++ " AS " ++ proto_crudl_utils:to_string(ColumnName) | Acc])
    end.


bind_select_params(Cnt, [], Acc) ->
    {Cnt, lists:reverse(Acc)};
bind_select_params(Cnt, [Name | Rest], Acc) ->
    bind_select_params(Cnt + 1, Rest, [proto_crudl_utils:to_string(Name) ++ " = $" ++ integer_to_list(Cnt) | Acc]).


-spec build_select_map(#table{}) -> string().
build_select_map(#table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:to_string(Pkey) ++ " := " ++
                               proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("#{" ++ lists:join(", ", PKColumns) ++ "}").

-spec build_select_record(string(), #table{}) -> string().
build_select_record(RecordName, #table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:to_string(Pkey) ++ " = " ++
                               proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", PKColumns) ++ "}").


-spec build_select_params(#table{}) -> string().
build_select_params(#table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("[" ++ lists:join(", ", PKColumns) ++ "]").


-spec build_lookup_list_sql(Table :: #table{}) -> SelectStmt :: string().
%% @doc This function will return a list of LOOKUP statements based on the applied excluded columns and transformations
build_lookup_list_sql(Table) ->
    IndexList = lists:reverse(Table#table.indexes),
    build_lookup_list_sql(Table, IndexList, []).

build_lookup_list_sql(_Table, [], Acc) ->
    Acc;
build_lookup_list_sql(Table, [Index | Rest], Acc) ->
    case is_lookuplist(Index) of
        false ->
            build_lookup_list_sql(Table, Rest, Acc);
        true ->
            % Its a list index
            LookupName = Index#index.name,
            LookupStr = build_lookup_list_sql(Table, Index),
            build_lookup_list_sql(Table, Rest, [{LookupName, LookupStr} | Acc])
    end.

build_lookup_list_sql(Table, Index) ->
    Schema = proto_crudl_utils:to_string(Index#index.table_schema),
    Name = proto_crudl_utils:to_string(Index#index.table_name),
    ColDict = Table#table.columns,
    SelectList = Table#table.select_list,
    LookupColumns = Index#index.columns,

    {_Cnt, LookupColumns1} = bind_select_params(1, LookupColumns, []),

    % Now build our select clause using all the columns except those that are excluded
    Clause1 = build_select_clause(SelectList, ColDict, []),
    Clause2 = build_select_xforms(SelectList, ColDict, []),

    lists:flatten("SELECT " ++ lists:join(", ", lists:append(Clause1, Clause2)) ++
                  " FROM " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                  " WHERE " ++ lists:join(" AND ", LookupColumns1)).

-spec build_lookup_list_map(string() | undefined, [binary()]) -> string().
build_lookup_list_map(undefined, LookupColumns) ->
    Columns = lists:reverse([proto_crudl_utils:to_string(C) ++ " := " ++
                             proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- LookupColumns]),
    lists:flatten("#{" ++ lists:join(", ", Columns) ++ "}");
build_lookup_list_map(RecordName, LookupColumns) ->
    Columns = lists:reverse([proto_crudl_utils:to_string(C) ++ " = " ++
                             proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- LookupColumns]),
    lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", Columns) ++ "}").

-spec build_list_params([binary()]) -> string().
build_list_params(LookupColumns) ->
    Columns = [proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- LookupColumns],
    lists:flatten("[" ++ lists:join(", ", Columns) ++ ", Limit, Offset]").

-spec build_lookup_params([binary()]) -> string().
build_lookup_params(LookupColumns) ->
    Columns = [proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- LookupColumns],
    lists:flatten("[" ++ lists:join(", ", Columns) ++ "]").



maybe_expand_all(#table{columns = ColDict, select_list = SelectList}, FunSql) ->
    case string:to_lower(FunSql) of
        [$s, $e, $l, $e, $c, $t, 32, $*, 32, $f, $r, $o, $m | _Rest] ->
            Clause1 = build_select_clause(SelectList, ColDict, []),
            Clause2 = build_select_xforms(SelectList, ColDict, []),
            ClauseStr = lists:join(", ", lists:append(Clause1, Clause2)),
            lists:flatten(string:replace(FunSql, "*", ClauseStr));
        _ ->
            FunSql
    end.

%% ---- DELETE ----

-spec build_delete_sql(Schema :: binary(), Name :: binary(), Table :: #table{}) -> DeleteStmt :: string().
%% @doc This function will return the DELETE statement based on the applied excluded columns and transformations
build_delete_sql(Schema, Name, Table) ->
    logger:info("Schema=~p, Table=~p", [Schema, Name]),
    PKColumns = lists:reverse([Pkey || Pkey <- Table#table.pkey_list]),
    {_Cnt, PKColumns1} = bind_select_params(1, PKColumns, []),
    lists:flatten("DELETE FROM " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                  " WHERE " ++ lists:join(" AND ", PKColumns1)).



-spec build_delete_map(#table{}) -> string().
build_delete_map(#table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:to_string(Pkey) ++ " := " ++
                               proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("#{" ++ lists:join(", ", PKColumns) ++ "}").

-spec build_delete_record(string(), #table{}) -> string().
build_delete_record(RecordName, #table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:to_string(Pkey) ++ " = " ++
                               proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", PKColumns) ++ "}").


-spec build_delete_params(#table{}) -> string().
build_delete_params(#table{pkey_list = Pkeys}) ->
    PKColumns = lists:reverse([proto_crudl_utils:camel_case(proto_crudl_utils:to_string(Pkey)) || Pkey <- Pkeys]),
    lists:flatten("[" ++ lists:join(", ", PKColumns) ++ "]").



%% ---- UPDATE ----

-spec build_update_sql(Schema :: binary(), Name :: binary(), Table :: #table{}) -> UpdateStmt :: string().
%% @doc This function will return the UPDATE statement based on the applied excluded columns and transformations
build_update_sql(Schema, Name, Table) ->
    ColDict = Table#table.columns,
    SelectList = Table#table.select_list,
    UpdateList = Table#table.update_list,

    PKColumns = lists:reverse([Pkey || Pkey <- Table#table.pkey_list]),
    {Cnt, PKColumns1} = bind_select_params(1, PKColumns, []),

    {NewCnt, Clause} = build_update_clause(Cnt, UpdateList, ColDict, []),

    ColumnList = orddict:fetch_keys(ColDict),
    Clause1 = build_update_xforms(ColDict, ColumnList, NewCnt, []),
    Clause2 = lists:append(Clause, Clause1),

    % We need our update to return the record...
    RetClause1 = build_select_clause(SelectList, ColDict, []),
    RetClause2 = build_select_xforms(SelectList, ColDict, []),

    logger:info("Clause2=~p, PKColumns1=~p", [Clause2, PKColumns1]),
    lists:flatten("UPDATE " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                   " SET " ++ lists:join(", ", Clause2) ++ " WHERE " ++ lists:join(" AND ", PKColumns1) ++
                   " RETURNING " ++ lists:join(", ", lists:append(RetClause1, RetClause2))).


build_update_clause(Cnt, [], _ColDict, ClauseAcc) ->
    {Cnt, lists:reverse(ClauseAcc)};
build_update_clause(Cnt, [ColumnName | Rest], ColDict, CAcc) ->
    Cname = proto_crudl_utils:to_string(ColumnName),
    Column = orddict:fetch(ColumnName, ColDict),
    case {Column#column.is_sequence, Column#column.data_type, Column#column.is_pkey} of
        {true, _, _} ->
            build_update_clause(Cnt, Rest, ColDict, CAcc);
        {_, _, true} ->
            build_update_clause(Cnt, Rest, ColDict, CAcc);
        {_, <<"virtual">>, _} ->
            build_update_clause(Cnt, Rest, ColDict, CAcc);
        {_, _, _} ->
            build_update_clause(Cnt + 1, Rest, ColDict, [Cname ++ " = $" ++ integer_to_list(Cnt) | CAcc])
    end.

build_update_xforms(_ColDict, [], _Pos, Clause) ->
    lists:reverse(Clause);
build_update_xforms(ColDict, [ColumnName | Rest], Pos, Clause) ->
    Column = orddict:fetch(ColumnName, ColDict),
    case Column#column.update_xform of
        undefined ->
            build_update_xforms(ColDict, Rest, Pos, Clause);
        Operation ->
            % Need to map the columns to the select params
            {NewPos, NewFun} = rewrite_xform_fun(Pos, proto_crudl_utils:to_string(Operation)),
            Cname = proto_crudl_utils:to_string(ColumnName),
            build_update_xforms(ColDict, Rest, NewPos, [Cname ++ " = " ++ NewFun])
    end.


-spec build_update_map(#table{}) -> string().
build_update_map(#table{select_list = SelectList}) ->
    UpdateColumns = lists:reverse([proto_crudl_utils:to_string(C) ++ " := " ++
                                   proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- SelectList]),
    lists:flatten("#{" ++ lists:join(", ", UpdateColumns) ++ "}").

-spec build_update_record(string() | undefined, #table{}) -> string().
build_update_record(RecordName, #table{select_list = SelectList}) ->
    UpdateColumns = [proto_crudl_utils:to_string(C) ++ " = " ++
                     proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- SelectList],
    lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", UpdateColumns) ++ "}").


-spec build_update_params(#table{}) -> string().
build_update_params(#table{select_list = SelectList, columns = ColDict}) ->
    UpdateColumns = handle_mapped_params(ColDict, SelectList, []),
    lists:flatten("[" ++ lists:join(", ", UpdateColumns) ++ "]").


%% ---- INSERT ----

-spec build_insert_sql(string(), string(), #table{}) -> InsertStmt :: string().
%% @doc This function will return the INSERT statement based on the applied excluded columns and transformations
build_insert_sql(S, N, Table) ->
    ColDict = Table#table.columns,
    SelectList = Table#table.select_list,
    InsertList = Table#table.insert_list,

    {Cnt, Clause, Params} = build_insert_clause(1, InsertList, ColDict, [], []),

    % Now add the insert transforms
    ColumnList = orddict:fetch_keys(ColDict),
    {Clause1, Params1} = build_insert_xforms(ColDict, ColumnList, Cnt, [], []),

    Clause2 = lists:append(Clause, Clause1),
    Params2 = lists:append(Params, Params1),

    % We need our update to return the record...
    RetClause1 = build_select_clause(SelectList, ColDict, []),
    RetClause2 = build_select_xforms(SelectList, ColDict, []),

    % Now, we need our to add any transforms to the values. For example, the column geog would have an input
    % that would include the lat, lng and then the output of the geog with a function that references those inputs.

    logger:info("Clause=~p, Params=~p", [Clause2, Params2]),
    lists:flatten("INSERT INTO " ++ proto_crudl_utils:to_string(S) ++ "." ++ proto_crudl_utils:to_string(N) ++
                  " (" ++ lists:join(", ", Clause2) ++ ") VALUES (" ++ lists:join(", ", Params2) ++ ")" ++
                  " RETURNING " ++ lists:join(", ", lists:append(RetClause1, RetClause2))).


build_insert_clause(Cnt, [], _ColDict, ClauseAcc, ParamsAcc) ->
    {Cnt, lists:reverse(ClauseAcc), lists:reverse(ParamsAcc)};
build_insert_clause(Cnt, [ColumnName | Rest], ColDict, CAcc, PAcc) ->
    Column = orddict:fetch(ColumnName, ColDict),
    case {Column#column.is_sequence, Column#column.data_type} of
        {true, _} ->
            build_insert_clause(Cnt, Rest, ColDict, CAcc, PAcc);
        {false, <<"virtual">>} ->
            build_insert_clause(Cnt, Rest, ColDict, CAcc, PAcc);
        {false, _} ->
            build_insert_clause(Cnt + 1, Rest, ColDict,
                                [proto_crudl_utils:to_string(ColumnName) | CAcc],
                                ["$" ++ integer_to_list(Cnt) | PAcc])
    end.


build_insert_xforms(_ColDict, [], _Pos, Clause, Params) ->
    {lists:reverse(Clause), lists:reverse(Params)};
build_insert_xforms(ColDict, [ColumnName | Rest], Pos, Clause, Params) ->
    Column = orddict:fetch(ColumnName, ColDict),
    case Column#column.insert_xform of
        undefined ->
            build_insert_xforms(ColDict, Rest, Pos, Clause, Params);
        Operation ->
            % Need to map the columns to the select params
            {NewPos, NewFun} = rewrite_xform_fun(Pos, proto_crudl_utils:to_string(Operation)),
            build_insert_xforms(ColDict, Rest, NewPos,
                                [proto_crudl_utils:to_string(ColumnName) | Clause],
                                [NewFun | Params])
    end.


-spec build_insert_defaults_sql(Schema :: binary(), Name :: binary(), Table :: #table{}) -> InsertStmt :: string().
%% @doc This function will return the INSERT_DEFAULTS statement based on the applied excluded columns and transformations
build_insert_defaults_sql(Schema, Name, #table{columns = ColDict,
                                               insert_list = InsertList,
                                               select_list = SelectList,
                                               default_list = DefaultList}) ->
    IList = [C || C <- InsertList, lists:member(C, DefaultList) == false],

    logger:info("Schema=~p, Table=~p, IList=~p", [Schema, Name, IList]),

    {Cnt, Clause, Params} = build_insert_clause(1, IList, ColDict, [], []),

    % Now add the insert transforms
    ColumnList = orddict:fetch_keys(ColDict),
    {Clause1, Params1} = build_insert_xforms(ColDict, ColumnList, Cnt, [], []),

    Clause2 = lists:append(Clause, Clause1),
    Params2 = lists:append(Params, Params1),

    % We need our update to return the record...
    RetClause1 = build_select_clause(SelectList, ColDict, []),
    RetClause2 = build_select_xforms(SelectList, ColDict, []),

    % Now, we need our to add any transforms to the values. For example, the column geog would have an input
    % that would include the lat, lng and then the output of the geog with a function that references those inputs.

    lists:flatten("INSERT INTO " ++ proto_crudl_utils:to_string(Schema) ++ "." ++ proto_crudl_utils:to_string(Name) ++
                  " (" ++ lists:join(", ", Clause2) ++ ") VALUES (" ++ lists:join(", ", Params2) ++ ")" ++
                  " RETURNING " ++ lists:join(", ", lists:append(RetClause1, RetClause2))).


-spec build_insert_map(#table{}) -> {string(), string()}.
build_insert_map(#table{insert_list = InsertList, default_list = DefaultList}) ->
    InsertColumns = lists:reverse([proto_crudl_utils:to_string(C) ++ " := " ++
                                   proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- InsertList]),
    InsertColumnsWODefault = lists:reverse([proto_crudl_utils:to_string(C) ++ " := " ++
                                            proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- InsertList,
                                            lists:member(C, DefaultList) == false]),
    {lists:flatten("#{" ++ lists:join(", ", InsertColumns) ++ "}"),
     lists:flatten("#{" ++ lists:join(", ", InsertColumnsWODefault) ++ "}")}.

-spec build_insert_record(string(), #table{}) -> {string(), string()}.
build_insert_record(RecordName, #table{insert_list = InsertList, default_list = DefaultList}) ->
    InsertColumns = [proto_crudl_utils:to_string(C) ++ " = " ++
                     proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) || C <- InsertList],
    Fun = fun(C, Acc) ->
            case lists:member(C, DefaultList) of
                true -> [proto_crudl_utils:to_string(C) ++ " = " ++"undefined" | Acc];
                _ -> [proto_crudl_utils:to_string(C) ++ " = " ++ proto_crudl_utils:camel_case(proto_crudl_utils:to_string(C)) | Acc]
            end
          end,
    InsertColumnsWODefaults = lists:reverse(lists:foldl(Fun, [], InsertList)),
    {lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", InsertColumns) ++ "}"),
     lists:flatten("#" ++ RecordName ++ "{" ++ lists:join(", ", InsertColumnsWODefaults) ++ "}")}.

-spec build_insert_params(#table{}) -> {string(), string()}.
build_insert_params(#table{insert_list = InsertList, default_list = DefaultList, columns = ColDict}) ->
    InsertColumns = handle_mapped_params(ColDict, InsertList, []),
    InsertColumnsWODefaults = handle_mapped_params(ColDict, lists:subtract(InsertList, DefaultList), []),
    {lists:flatten("[" ++ lists:join(", ", InsertColumns) ++ "]"),
     lists:flatten("[" ++ lists:join(", ", InsertColumnsWODefaults) ++ "]")}.


handle_mapped_params(_ColDict, [], Acc) ->
    lists:reverse(Acc);
handle_mapped_params(ColDict, [CName | Rest], Acc) ->
    C = orddict:fetch(CName, ColDict),
    case length(C#column.valid_values) of
        0 ->
            case proto_crudl_psql:is_timestamp(C#column.udt_name) of
                true ->
                    handle_mapped_params(ColDict, Rest, ["ts_decode_map(" ++ proto_crudl_utils:camel_case(CName) ++ ")" | Acc]);
                false ->
                    handle_mapped_params(ColDict, Rest, [proto_crudl_utils:camel_case(proto_crudl_utils:to_string(CName)) | Acc])
            end;
        _ ->
            handle_mapped_params(ColDict, Rest, [proto_crudl_utils:to_string(CName) ++ "_value(" ++
                                                 proto_crudl_utils:camel_case(CName) ++ ")" | Acc])
    end.


-spec rewrite_xform_fun(integer(), binary()) -> {integer(), string()}.
rewrite_xform_fun(Pos, Operator) ->
    case erl_scan:string(Operator) of
        {ok, Tokens, _} ->
            % The expected cases are: [$column, ...], func($column1, ...)], [func()], [func(func($column1, ...))]
            logger:info("Tokens=~p, Pos=~p", [Tokens, Pos]),
            rewrite_func_params(Pos, Operator, Tokens);
        {error, Reason} ->
            io:format("ERROR: Failed to parse transform function. Fun=~p, Reason=~p", [Operator, Reason]),
            failed
    end.


-spec rewrite_func_params(integer(), string(), list()) -> {integer(), string()}.
rewrite_func_params(Pos, Fun, []) ->
    {Pos, Fun};
rewrite_func_params(Pos, Fun, [{char, 1, Chr}, {atom, 1, Remaining} | Rest]) ->
    % We have the parameter name
    Name = proto_crudl_utils:to_binary(lists:flatten([Chr, atom_to_list(Remaining)])),
    % Now find the position in the read list
    logger:info("Name=~p, Pos=~p", [Name, Pos]),
    NewFun = lists:flatten(string:replace(Fun, "$" ++ Name, "$" ++ integer_to_list(Pos))),
    rewrite_func_params(Pos + 1, NewFun, Rest);
rewrite_func_params(Pos, Fun, [{char, 1, Chr} | Rest]) ->
    Name = proto_crudl_utils:to_binary(lists:flatten([Chr])),
    NewFun = lists:flatten(string:replace(Fun, "$" ++ Name, "$" ++ integer_to_list(Pos))),
    logger:info("NewFun=~p~n", [NewFun]),
    rewrite_func_params(Pos + 1, NewFun, Rest);
rewrite_func_params(Pos, Fun, [_H | Rest]) ->
    rewrite_func_params(Pos, Fun, Rest).

-spec build_enum_case(#table{}) -> string().
build_enum_case(#table{columns = ColDict}) ->
    build_enum_cases(orddict:to_list(ColDict), "").

build_enum_cases([], Acc) ->
    Acc;
build_enum_cases([{_Key, #column{name = N, valid_values = VV}} | Rest], Acc) when length(VV) > 0 ->
    Name = proto_crudl_utils:camel_case(N),
    UpperSnakeCase = proto_crudl_utils:capitalize(Name),
    Len = length(Name) + 12,
    Str = "    " ++ Name ++ "Value = case maps:get(" ++ Name ++ ", ?" ++ UpperSnakeCase ++ "_ENUMS) of\n" ++
          proto_crudl_utils:spaces(Len + 4) ++ "{badkey, Key} ->\n" ++
          proto_crudl_utils:spaces(Len + 8) ++ "{error, {badkey, Key}};\n" ++
          proto_crudl_utils:spaces(Len + 4) ++ "Value__ ->\n" ++
          proto_crudl_utils:spaces(Len + 8) ++ "Value__\n" ++
          proto_crudl_utils:spaces(Len) ++ "end,\n",
    build_enum_cases(Rest, [Str, Acc]);
build_enum_cases([_Head | Rest], Acc) ->
    build_enum_cases(Rest, Acc).


%%
%% Tests
%%
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-include_lib("kernel/include/logger.hrl").

-define(DROP_DB, "DROP DATABASE proto_crudl").
-define(CREATE_DB, "CREATE DATABASE proto_crudl WITH OWNER = proto_crudl ENCODING = 'UTF8' TEMPLATE = template0 CONNECTION LIMIT = -1").

first_test() ->
    logger:set_primary_config(level, info),
    application:ensure_all_started(pgo),
    application:set_env(pg_types, uuid_format, string),
    pgo:start_pool(default, #{pool_size => 10,
                              host => "127.0.0.1",
                              port => 5432,
                              database => "proto_crudl",
                              user => "proto_crudl",
                              password => "proto_crudl"}),

    ok.

is_lookuplist_test() ->
    I0 = #index{},
    I1 = #index{is_list = true},
    I2 = #index{is_lookup = true},

    false = is_lookuplist(I0),
    true = is_lookuplist(I1),
    true = is_lookuplist(I2).

define_test() ->
    ?LOG_INFO("====================== define_test() START ======================"),

    {ok, Database} = proto_crudl_psql:read_database([{schemas, ["public", "test_schema"]},
                                                   {excluded, ["public.excluded", "spatial_ref_sys"]}]),

    Configs = [
        {transforms, [
            {"test_schema.user", [
                % For the select transform, we need to know the datatype of the product of the transform. This is needed for
                % generating the protobufs
                {select, [{"lat", "decimal", "ST_Y(geog::geometry)"},
                          {"lon", "decimal", "ST_X(geog::geometry)"}]},
                {insert, [{"geog", "geography", "ST_POINT($lat, $lon)::geography"}]},
                {update, [{"geog", "geography", "ST_POINT($lat, $lon)::geography"}]}]},
            {"public.foo", [
                {select, [{"foobar", "integer", "1"}]}]}
        ]},
        {exclude_columns, [
            {"test_schema.user", ["pword_hash", "geog"]}
        ]},
        {mapping, [
            {"test_schema.user", [
                {get_pword_hash, "SELECT pword_hash FROM test_schema.user WHERE email = $1"},
                {update_pword_hash, "UPDATE test_schema.user SET pword_hash = $2 WHERE email = $1"},
                {reset_pword_hash, "UPDATE test_schema.user SET pword_hash = NULL WHERE email = $1"},
                {disable_user, "UPDATE test_schema.user SET enabled = false WHERE email = $1"},
                {enable_user, "UPDATE test_schema.user SET enabled = true WHERE email = $1"},
                {delete_user_by_email, "DELETE FROM test_schema.user WHERE email = $1"},
                {set_token, "UPDATE test_schema.user SET user_token = uuid_generate_v4() WHERE user_id = $1 RETURNING user_token"},
                {find_nearest, "SELECT *, ST_X(geog::geometry) AS lon, ST_Y(geog::geometry) AS lat FROM address "
                               "WHERE ST_DWithin( geog, Geography(ST_MakePoint($1, $2)), $3 ) AND lat != 0.0 AND lng != 0.0 "
                               "ORDER BY geog <-> ST_POINT($1, $2)::geography"}
            ]}
        ]}],

    {ok, Database1} = proto_crudl:process_configs(Configs, Database),
    TablesDict = Database1#database.tables,
    {ok, UserTable} = dict:find(<<"test_schema.user">>, TablesDict),

    S = UserTable#table.schema,
    N = UserTable#table.name,

    SelectOutput = build_select_sql(S, N, UserTable),
    ?LOG_INFO("SelectOutput=~p~n", [SelectOutput]),
    SelectAssert = "SELECT user_id, first_name, last_name, email, user_token, enabled, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, ST_Y(geog::geometry) AS lat, ST_X(geog::geometry) AS lon FROM test_schema.user WHERE user_id = $1",
    ?assertEqual(SelectAssert, SelectOutput),

    InsertOutput = build_insert_sql(S, N, UserTable),
    ?LOG_INFO("InsertOutput=~p~n", [InsertOutput]),
    InsertAssert = "INSERT INTO test_schema.user (first_name, last_name, email, user_token, enabled, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, geog) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, ST_POINT($13, $14)::geography) RETURNING user_id, first_name, last_name, email, user_token, enabled, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, ST_Y(geog::geometry) AS lat, ST_X(geog::geometry) AS lon",
    ?assertEqual(InsertAssert, InsertOutput),

    DefaultOutput = build_insert_defaults_sql(S, N, UserTable),
    ?LOG_INFO("DefaultOutput=~p~n", [DefaultOutput]),
    DefaultAssert = "INSERT INTO test_schema.user (first_name, last_name, email, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, geog) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, ST_POINT($11, $12)::geography) RETURNING user_id, first_name, last_name, email, user_token, enabled, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, ST_Y(geog::geometry) AS lat, ST_X(geog::geometry) AS lon",
    ?assertEqual(DefaultAssert, DefaultOutput),

    UpdateOutput = build_update_sql(S, N, UserTable),
    ?LOG_INFO("UpdateOutput=~p~n", [UpdateOutput]),
    UpdateAssert = "UPDATE test_schema.user SET first_name = $2, last_name = $3, email = $4, user_token = $5, enabled = $6, aka_id = $7, my_array = $8, user_type = $9, number_value = $10, created_on = $11, updated_on = $12, due_date = $13, geog = ST_POINT($14, $15)::geography WHERE user_id = $1 RETURNING user_id, first_name, last_name, email, user_token, enabled, aka_id, my_array, user_type, number_value, created_on, updated_on, due_date, ST_Y(geog::geometry) AS lat, ST_X(geog::geometry) AS lon",
    ?assertEqual(UpdateAssert, UpdateOutput),

    DeleteOutput = build_delete_sql(S, N, UserTable),
    ?LOG_INFO("DeleteOutput=~p~n", [DeleteOutput]),
    DeleteAssert = "DELETE FROM test_schema.user WHERE user_id = $1",
    ?assertEqual(DeleteAssert, DeleteOutput),

    ?LOG_INFO("====================== define_test() END ======================"),
    ok.


cleanup_version([]) ->
    ok;
cleanup_version([{_Key, T0} | Rest]) ->
    Alter = "ALTER TABLE " ++ binary_to_list(T0#table.schema) ++ "." ++ binary_to_list(T0#table.name) ++
                                                                        " DROP COLUMN version",
    case pgo:query(Alter, [], #{decode_opts => [{return_rows_as_maps, true}, {column_name_as_atom, true}]}) of
        #{command := alter, num_rows := table, rows := []} ->
            cleanup_version(Rest);
        {error, Reason} ->
            io:format("    WARNING: Failed to get alter table ~p.~p. Reason=~p, Stmt=~p~n",
                      [T0#table.schema, T0#table.name, Reason, Alter]),
            ok
    end.

last_test() ->
    ?LOG_INFO("====================== CLEANING UP VERSION COLUMNS ======================"),
    {ok, Database} = proto_crudl_psql:read_database([{schemas, ["public", "test_schema"]},
                                                   {excluded, ["public.excluded", "spatial_ref_sys"]}]),

    TablesDict = Database#database.tables,
    ok = cleanup_version(dict:to_list(TablesDict)).

-endif.