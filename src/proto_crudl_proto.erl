%%%-------------------------------------------------------------------
%%% @author bryan
%%% @copyright (C) 2021, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 02. Feb 2021 2:51 PM
%%%-------------------------------------------------------------------
-module(proto_crudl_proto).
-author("bryan").

%% API
-export([generate/2, make_enum_label/1]).

-include("proto_crudl.hrl").

-spec generate([{atom(), string()}], #database{}) -> ok | failed.
generate(Options, #database{tables = TableDict}) ->
    Path = proplists:get_value(path, Options, "output/proto"),
    JavaPackage = proplists:get_value(java_package, Options),
    Version = proplists:get_value(version, Options),
    Keys = dict:fetch_keys(TableDict),
    io:format("~n------- Generating Protobuffers --------~n"),
    generate(Version, Path, JavaPackage, TableDict, Keys).


-spec generate(string(), string(), string(), dict:dict(), [binary()]) -> ok | failed.
generate(_Version, _Path, _JavaPackage, _TableDict, []) ->
    ok;
generate(Version, Path, JavaPackage, TableDict, [FQN | Rest]) ->
    Table = dict:fetch(FQN, TableDict),
    Schema = proto_crudl_utils:to_string(Table#table.schema),
    Name = proto_crudl_utils:to_string(Table#table.name),
    ProtoFile = filename:join([Path, Schema, Name ++ ".proto"]),
    io:format("~p~n", [ProtoFile]),

    case filelib:ensure_dir(ProtoFile) of
        ok ->
            write_proto(Version, ProtoFile, JavaPackage, Table),
            write_raw_proto(Version, ProtoFile, Table),
            write_custom_proto(Version, ProtoFile, Table),
            generate(Version, Path, JavaPackage, TableDict, Rest);
        {error, eexist} ->
            write_proto(Version, ProtoFile, JavaPackage, Table),
            write_raw_proto(Version, ProtoFile, Table),
            write_custom_proto(Version, ProtoFile, Table),
            generate(Version, Path, JavaPackage, TableDict, Rest);
        {error, eacces} -> io:format("Missing search or write permissions for the parent directories of ~p~n",
                                     [ProtoFile]),
            {error, eaccess};
        {error, enoent} -> io:format("A component of ~p does not exist~n", [ProtoFile]),
            {error, enoent};
        {error, enospc} -> io:format("No space is left on the device~n", []),
            {error, enospc};
        {error, enotdir} -> io:format("A component of ~p is not a directory. On some platforms, enoent is "
                                      "returned instead~n", [ProtoFile]),
            {error, enotdir}
    end.

write_proto(Version, ProtoFile, JavaPackage, Table) ->
    Header = "//-------------------------------------------------------------------\n"
             "// This file is automatically generated from the database schema.\n"
             "// ---- DO NOT MAKE CHANGES DIRECTLY TO THIS FILE! ----\n\n"
             "syntax = \"" ++ Version ++ "\";\n\n",
    ok = file:write_file(ProtoFile, Header, [write]),

    Schema = proto_crudl_utils:to_string(Table#table.schema),
    TableName = proto_crudl_utils:to_string(Table#table.name),

    % The proto package is the database schema, otherwise we will have collisions
    ok = file:write_file(ProtoFile, "package " ++ Schema ++ ";\n\n", [append]),

    % Write the options (if specified)
    MessageName = proto_crudl_utils:camel_case(TableName),
    write_options(ProtoFile, Schema, MessageName, JavaPackage),

    % Write the other imports first, like support for Timestamps
    ok = file:write_file(ProtoFile, "\n// Other imports\n", [append]),
    Fun = fun(_ColumnName, Column, List) ->
                Line = write_special_imports(Column#column.udt_name),
                case lists:member(Line, List) of
                    true -> List;
                    false -> [Line | List]
                end
          end,
    ImportList = orddict:fold(Fun, [], Table#table.columns),
    [ok = file:write_file(ProtoFile, Line, [append]) || Line <- ImportList],

    ok = file:write_file(ProtoFile, "\nmessage " ++ MessageName ++ " {\n", [append]),

    % Write extension
    case Table#table.proto_extension of
        undefined -> ok;
        E -> ok = file:write_file(ProtoFile, "  extensions " ++ E ++ ";\n", [append])
    end,

    % Write enums
    Code = write_proto_enums(Table),
    ok = file:write_file(ProtoFile, Code, [append]),

    % Write fields
    {_FieldNo, LineList} = write_proto_fields(Version, Table),
    [ok = file:write_file(ProtoFile, Line, [append]) || Line <- lists:reverse(LineList)],
    ok = file:write_file(ProtoFile, "}\n\n", [append]).


write_options(ProtoFile, Schema, MessageName, JavaPackage) ->
    Option = "option cc_enable_arenas = true;\n"
             "option java_package = \"" ++ JavaPackage ++ "." ++ Schema ++ "\";\n"
             "option java_outer_classname = \"" ++
        MessageName ++ "Proto\";\n"
                       "option java_multiple_files = true;\n"
                       "option objc_class_prefix = \"EDM\";\n\n",
    ok = file:write_file(ProtoFile, Option, [append]).


write_special_imports(<<116, 105, 109, 101, 115, 116, 97, 109, 112, _Rest/binary>>) ->
    "import \"google/protobuf/timestamp.proto\";\n";
write_special_imports(_UdtName) ->
    "".


write_proto_enums(#table{has_valid_values = false}) ->
    "";
write_proto_enums(#table{columns = ColDict}) ->
    Fun = fun(ColumnName, #column{valid_values = ValidValues}, Acc) ->
                case length(ValidValues) of
                    0 ->
                        Acc;
                    _ ->
                        Line = "  enum " ++ proto_crudl_utils:camel_case(ColumnName) ++ " {\n",
                        Inner = fun(Value, {FieldNo, List}) ->
                                    V = make_enum_label(proto_crudl_utils:to_string(Value)),
                                    {FieldNo + 1, ["    " ++ V ++ " = " ++ integer_to_list(FieldNo) ++ ";\n" | List]}
                                end,
                        {_FieldNo, Lines} = lists:foldl(Inner, {0, [Line]}, ValidValues),
                        lists:flatten(lists:reverse(Lines)) ++ "  }\n"
                end
          end,
    orddict:fold(Fun, "", ColDict).


-spec make_enum_label(string()) -> string().
make_enum_label(Value) when is_binary(Value) ->
    make_enum_label(proto_crudl_utils:to_string(Value));
make_enum_label(Value) ->
    Value2 = lists:flatten(string:replace(string:replace(Value, "-", "_"), " ", "_")),
    case [Char || Char <- Value2, Char >= $0 andalso Char =< $9] of
        [] ->
            Value2;
        _ ->
            "_" ++ Value2
    end.

write_proto_fields(Version, #table{columns = ColDict, select_list = SList}) ->
    Fun1 = fun(ColumnName, {FieldNo, List}) ->
                Column = orddict:fetch(ColumnName, ColDict),
                DataType = Column#column.data_type,
                UdtName = Column#column.udt_name,
                FieldType = case Column#column.valid_values of
                                [] -> proto_crudl_psql:sql_to_proto_datatype(UdtName);
                                _ -> proto_crudl_utils:camel_case(ColumnName)
                            end,
                Repeated = case DataType of
                               <<"ARRAY">> -> "repeated ";
                               _ -> case Version of "proto2" -> "optional "; _ -> "" end
                           end,
                Line = "  " ++ Repeated ++ FieldType ++ " " ++
                               proto_crudl_utils:to_string(ColumnName) ++ " = " ++
                               integer_to_list(FieldNo) ++ ";\n",
                case lists:member(Line, List) of
                    true -> {FieldNo, List};
                    false -> {FieldNo + 1, [Line | List]}
                end
           end,
    lists:foldl(Fun1, {1, []}, SList).

write_raw_proto(Version, ProtoFile, T = #table{name = Name}) ->
    Break = "//-------------------------- Index Proto -----------------------------\n\n",
    ok = file:write_file(ProtoFile, Break, [append]),
    Code = write_raw_message(Version, Name, T),
    file:write_file(ProtoFile, Code, [append]).

write_raw_message(Version, Name, Table = #table{columns = ColDict}) ->
    {_FieldNo, LineList} = write_all_fields(Version, orddict:to_list(ColDict)),
    "message Raw" ++ proto_crudl_utils:camel_case(Name) ++ "{\n" ++
    case Table#table.proto_extension of
       undefined -> "";
       E -> "  extensions " ++ E ++ ";\n"
    end ++
        write_proto_enums(Table) ++
        lists:reverse(LineList) ++
    "}\n\n".

write_all_fields(Version, Columns) ->
    Fun1 = fun({ColumnName, Column}, {FieldNo, List}) ->
                DataType = Column#column.data_type,
                UdtName = Column#column.udt_name,
                FieldType = case Column#column.valid_values of
                                [] -> proto_crudl_psql:sql_to_proto_datatype(UdtName);
                                _ -> proto_crudl_utils:camel_case(ColumnName)
                            end,
                Repeated = case DataType of
                               <<"ARRAY">> -> "repeated ";
                               _ -> case Version of "proto2" -> "optional "; _ -> "" end
                           end,
                Line = "  " ++ Repeated ++ FieldType ++ " " ++ proto_crudl_utils:to_string(ColumnName) ++ " = " ++ integer_to_list(FieldNo) ++ ";\n",
                case lists:member(Line, List) of
                    true -> {FieldNo, List};
                    false -> {FieldNo + 1, [Line | List]}
                end
           end,
    lists:foldl(Fun1, {1, []}, Columns).


write_custom_proto(Version, ProtoFile, _Table = #table{mappings = Mappings}) ->
    Break = "//-------------------------- Custom Queries -----------------------------\n\n",
    ok = file:write_file(ProtoFile, Break, [append]),
    Code = write_custom_message(Version, orddict:to_list(Mappings), []),
    file:write_file(ProtoFile, Code, [append]).

write_custom_message(_Version, [], Acc) ->
    lists:flatten(Acc);
write_custom_message(Version, [{Key, #custom_query{result_set = ResultSets}} | Rest], Acc) when length(ResultSets) > 0 ->
    {_FieldNo, LineList} = write_custom_fields(Version, ResultSets),
    Str = "message " ++ proto_crudl_utils:camel_case(Key) ++ "{\n" ++ lists:reverse(LineList) ++ "}\n\n",
    write_custom_message(Version, Rest, [Str | Acc]);
write_custom_message(Version, [_Head | Rest], Acc) ->
    write_custom_message(Version, Rest, Acc).

write_custom_fields(Version, ResultSets) ->
    Fun1 = fun(#bind_var{name = Name, data_type = DataType}, {FieldNo, List}) ->
                FieldType = proto_crudl_psql:sql_to_proto_datatype(DataType),
                Repeated = case string:prefix(DataType, <<"{array">>) of
                               nomatch -> case Version of "proto2" -> "optional "; _ -> "" end;
                               _ -> "repeated "
                           end,
                Line = "  " ++ Repeated ++ FieldType ++ " " ++ proto_crudl_utils:to_string(Name) ++ " = " ++
                       integer_to_list(FieldNo) ++ ";\n",
                case lists:member(Line, List) of
                    true -> {FieldNo, List};
                    false -> {FieldNo + 1, [Line | List]}
                end
           end,
    lists:foldl(Fun1, {1, []}, ResultSets).


%%
%% Tests
%%
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-include_lib("kernel/include/logger.hrl").

-define(DROP_DB, "DROP DATABASE proto_crudl").
-define(CREATE_DB, "CREATE DATABASE proto_crudl WITH OWNER = proto_crudl ENCODING = 'UTF8' TEMPLATE = template0 CONNECTION LIMIT = -1").

first_test() ->
    logger:set_primary_config(level, info),
    ok.

proto_test() ->
    ?LOG_INFO("====================== proto_test() START ======================"),

    {ok, C} = epgsql:connect(#{host => "localhost",
                               port => 5432,
                               username => "proto_crudl",
                               password => "proto_crudl",
                               database => "proto_crudl",
                               timeout => 4000}),

    {ok, Database} = proto_crudl_psql:read_database(C, [{schemas, ["public", "test_schema"]},
                                                        {excluded, ["public.excluded", "spatial_ref_sys"]}]),

    Configs = [
        {transforms, [
            {"test_schema.user", [
                % For the select transform, we need to know the datatype of the product of the transform. This is needed for
                % generating the protobufs
                {select, [{"lat", "decimal", "ST_Y(geog::geometry)"},
                          {"lon", "decimal", "ST_X(geog::geometry)"}]},
                {insert, [{"geog", "geography", "ST_POINT($lon, $lat)::geography"}]},
                {update, [{"geog", "geography", "ST_POINT($lon, $lat)::geography"}]}]},
            {"public.foo", [
                {select, [{"foobar", "integer", "1"}]}]}
        ]},
        {exclude_columns, [
            {"test_schema.user", ["pword_hash", "geog"]}
                          ]},
        {mapping, [
            {"test_schema.user", [
                {find_nearest, "SELECT * FROM test_schema.user "
                               "WHERE ST_DWithin(geog, Geography(ST_MakePoint($1, $2)), $3) "
                               "ORDER BY geog <-> ST_POINT($1, $2)::geography"}
            ]}
                  ]}],

    {ok, Database1} = proto_crudl:process_configs(C, Configs, Database),
    TablesDict = Database1#database.tables,
    {ok, UserTable} = dict:find(<<"test_schema.user">>, TablesDict),

    ?LOG_INFO("Mappings=~p", [UserTable#table.mappings]),
    Code = write_custom_message("proto2", orddict:to_list(UserTable#table.mappings), []),
    ?LOG_INFO("Code=~p", [Code]),

    Expected = "message FindNearest{
  optional int64 user_id = 1;
  optional string first_name = 2;
  optional string last_name = 3;
  optional string email = 4;
  optional string user_token = 5;
  optional bool enabled = 6;
  optional int64 aka_id = 7;
  repeated int32 my_array = 8;
  optional string user_type = 9;
  optional int32 number_value = 10;
  optional google.protobuf.Timestamp created_on = 11;
  optional google.protobuf.Timestamp updated_on = 12;
  optional int64 due_date = 13;
  optional double lat = 14;
  optional double lon = 15;
}\n\n",
    ?assertEqual(Expected, Code),

    ok = epgsql:close(C),

    ?LOG_INFO("====================== proto_test() END ======================"),
    ok.

cleanup_version(_C, []) ->
    ok;
cleanup_version(C, [{_Key, T0} | Rest]) ->
    Alter = "ALTER TABLE " ++ binary_to_list(T0#table.schema) ++ "." ++ binary_to_list(T0#table.name) ++
                                                                        " DROP COLUMN version",
    case epgsql:squery(C, Alter) of
        {ok, _Fields, _Rows} ->
            cleanup_version(C, Rest);
        {error, Reason} ->
            io:format("    WARNING: Failed to get alter table ~p.~p. Reason=~p, Stmt=~p~n",
                      [T0#table.schema, T0#table.name, Reason, Alter]),
            ok
    end.

last_test() ->
    ?LOG_INFO("====================== CLEANING UP VERSION COLUMNS ======================"),

    {ok, C} = epgsql:connect(#{host => "localhost",
                               port => 5432,
                               username => "proto_crudl",
                               password => "proto_crudl",
                               database => "proto_crudl",
                               timeout => 4000}),

    {ok, Database} = proto_crudl_psql:read_database(C, [{schemas, ["public", "test_schema"]},
                                                        {excluded, ["public.excluded", "spatial_ref_sys"]}]),

    TablesDict = Database#database.tables,
    ok = cleanup_version(C, dict:to_list(TablesDict)),
    ok = epgsql:close(C).

-endif.