%%%-------------------------------------------------------------------
%%% @author bryan
%%% @copyright (C) 2021, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 02. Feb 2021 2:51 PM
%%%-------------------------------------------------------------------
-module(erl_crudl_proto).
-author("bryan").

%% API
-export([generate/2, make_enum_label/1]).

-include("erl_crudl.hrl").

-spec generate([{atom(), string()}], #database{}) -> ok | failed.
generate(Options, #database{tables = TableDict}) ->
    Path = proplists:get_value(path, Options, "output/proto"),
    JavaPackage = proplists:get_value(java_package, Options),
    Version = proplists:get_value(version, Options),
    Keys = dict:fetch_keys(TableDict),
    io:format("~n------- Generating Protobuffers --------~n"),
    generate(Version, Path, JavaPackage, TableDict, Keys).


-spec generate(string(), string(), string(), dict:dict(), [binary()]) -> ok | failed.
generate(_Version, _Path, _JavaPackage, _TableDict, []) ->
    ok;
generate(Version, Path, JavaPackage, TableDict, [FQN | Rest]) ->
    Table = dict:fetch(FQN, TableDict),
    Schema = erl_crudl_utils:to_string(Table#table.schema),
    Name = erl_crudl_utils:to_string(Table#table.name),
    ProtoFile = filename:join([Path, Schema, Name ++ ".proto"]),
    io:format("~p~n", [ProtoFile]),

    case filelib:ensure_dir(ProtoFile) of
        ok ->
            write_proto(Version, ProtoFile, JavaPackage, Table),
            generate(Version, Path, JavaPackage, TableDict, Rest);
        {error, eexist} ->
            write_proto(Version, ProtoFile, JavaPackage, Table),
            generate(Version, Path, JavaPackage, TableDict, Rest);
        {error, eacces} -> io:format("Missing search or write permissions for the parent directories of ~p~n",
                                     [ProtoFile]),
            {error, eaccess};
        {error, enoent} -> io:format("A component of ~p does not exist~n", [ProtoFile]),
            {error, enoent};
        {error, enospc} -> io:format("No space is left on the device~n", []),
            {error, enospc};
        {error, enotdir} -> io:format("A component of ~p is not a directory. On some platforms, enoent is "
                                      "returned instead~n", [ProtoFile]),
            {error, enotdir}
    end.

write_proto(Version, ProtoFile, JavaPackage, Table) ->
    Header = "//-------------------------------------------------------------------\n"
             "// This file is automatically generated from the database schema.\n"
             "// ---- DO NOT MAKE CHANGES DIRECTLY TO THIS FILE! ----\n\n"
             "syntax = \"" ++ Version ++ "\";\n\n",
    ok = file:write_file(ProtoFile, Header, [write]),

    Schema = erl_crudl_utils:to_string(Table#table.schema),
    TableName = erl_crudl_utils:to_string(Table#table.name),

    % The proto package is the database schema, otherwise we will have collisions
    ok = file:write_file(ProtoFile, "package " ++ Schema ++ ";\n\n", [append]),

    % Write the options (if specified)
    MessageName = erl_crudl_utils:camel_case(TableName),
    write_options(ProtoFile, Schema, MessageName, JavaPackage),

    % Write the other imports first, like support for Timestamps
    ok = file:write_file(ProtoFile, "\n// Other imports\n", [append]),
    Fun = fun(_ColumnName, Column, List) ->
                Line = write_special_imports(Column#column.udt_name),
                case lists:member(Line, List) of
                    true -> List;
                    false -> [Line | List]
                end
          end,
    ImportList = orddict:fold(Fun, [], Table#table.columns),
    [ok = file:write_file(ProtoFile, Line, [append]) || Line <- ImportList],

    ok = file:write_file(ProtoFile, "\nmessage " ++ MessageName ++ " {\n", [append]),

    % Write extension
    case Table#table.proto_extension of
        undefined -> ok;
        E -> ok = file:write_file(ProtoFile, "  extensions " ++ E ++ ";\n", [append])
    end,

    % Write enums
    ok = write_proto_enums(ProtoFile, Table),

    % Write fields
    {_FieldNo, LineList} = write_proto_fields(Version, Table),
    [ok = file:write_file(ProtoFile, Line, [append]) || Line <- lists:reverse(LineList)],
    ok = file:write_file(ProtoFile, "}\n\n", [append]).


write_options(ProtoFile, Schema, MessageName, JavaPackage) ->
    Option = "option cc_enable_arenas = true;\n"
             "option java_package = \"" ++ JavaPackage ++ "." ++ Schema ++ "\";\n"
             "option java_outer_classname = \"" ++
        MessageName ++ "Proto\";\n"
                       "option java_multiple_files = true;\n"
                       "option objc_class_prefix = \"EDM\";\n\n",
    ok = file:write_file(ProtoFile, Option, [append]).


write_special_imports(<<116, 105, 109, 101, 115, 116, 97, 109, 112, _Rest/binary>>) ->
    "import \"google/protobuf/timestamp.proto\";\n";
write_special_imports(_UdtName) ->
    "".


write_proto_enums(_ProtoFile, #table{has_valid_values = false}) ->
    ok;
write_proto_enums(ProtoFile, #table{columns = ColDict}) ->
    Fun = fun(ColumnName, #column{valid_values = ValidValues}, Acc) ->
                case length(ValidValues) of
                    0 ->
                        Acc;
                    _ ->
                        Line = "  enum " ++ erl_crudl_utils:camel_case(ColumnName) ++ " {\n",
                        Inner = fun(Value, {FieldNo, List}) ->
                                    V = make_enum_label(erl_crudl_utils:to_string(Value)),
                                    {FieldNo + 1, ["    " ++ V ++ " = " ++ integer_to_list(FieldNo) ++ ";\n" | List]}
                                end,
                        {_FieldNo, Lines} = lists:foldl(Inner, {0, [Line]}, ValidValues),
                        [ok = file:write_file(ProtoFile, EnumLine, [append]) || EnumLine <- lists:reverse(Lines)],
                        ok = file:write_file(ProtoFile, "  }\n", [append]),
                        Acc
                end
          end,
    orddict:fold(Fun, [], ColDict),
    ok.


-spec make_enum_label(string()) -> string().
make_enum_label(Value) when is_binary(Value) ->
    make_enum_label(erl_crudl_utils:to_string(Value));
make_enum_label(Value) ->
    Value2 = lists:flatten(string:replace(string:replace(Value, "-", "_"), " ", "_")),
    case [Char || Char <- Value2, Char >= $0 andalso Char =< $9] of
        [] ->
            Value2;
        _ ->
            "_" ++ Value2
    end.


write_proto_fields(Version, #table{columns = ColDict, select_list = SList}) ->
    Fun1 = fun(ColumnName, {FieldNo, List}) ->
                Column = orddict:fetch(ColumnName, ColDict),
                DataType = Column#column.data_type,
                UdtName = Column#column.udt_name,
                FieldType = case Column#column.valid_values of
                                [] -> erl_crudl_psql:sql_to_proto_datatype(UdtName);
                                _ -> erl_crudl_utils:camel_case(ColumnName)
                            end,
                Repeated = case DataType of
                               <<"ARRAY">> -> "repeated ";
                               _ -> case Version of "proto2" -> "optional "; _ -> "" end
                           end,
                Line = "  " ++ Repeated ++ FieldType ++ " " ++
                               erl_crudl_utils:to_string(ColumnName) ++ " = " ++
                               integer_to_list(FieldNo) ++ ";\n",
                case lists:member(Line, List) of
                    true -> {FieldNo, List};
                    false -> {FieldNo + 1, [Line | List]}
                end
           end,
    lists:foldl(Fun1, {1, []}, SList).